<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>LionNet</title>
        <description>Programowanie, sieci komputerowe, informatyka.</description>      
        <link>http://lion.net.pl</link>
        <language>pl</language>
        <generator>Sculpin</generator>
        <category>IT</category>
        <atom:link href="http://lion.net.pl/blog/feed.xml" rel="self" type="application/rss+xml" />
                <item>
            <title>Jak zrobić zrzut ekranu całej strony internetowej?</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>WWW</category>
                                    <content:encoded>&lt;p&gt;Czasami chcemy zrobić szybko zrzut ekranu całej strony internetowej. Nie kawałka
strony widocznego aktualnie na ekranie monitora, tylko całej jej zawartości. Jak
zrobić to szybko i przy pomocy znanych narzędzi?&lt;/p&gt;

&lt;h3 id=&quot;chytre-narz%C4%99dzie&quot;&gt;Chytre narzędzie&lt;/h3&gt;

&lt;p&gt;Przeglądarkę stron WWW Mozilla FireFox zna chyba każdy. To świetne narzędzie do 
przeglądania ma w sobie wbudowaną funkcjonalność robienia &lt;em&gt;&quot;screenów&quot;&lt;/em&gt; całej 
strony. Aby wykonać zrzut ekranu należy:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Wejść do narzędzi dla programistów klikając w ikonę menu, &lt;em&gt;&quot;Otwórz menu&quot;&lt;/em&gt;, (trzy 
poziome belki na pasku narzędzi przeglądarki) bądź naciskając klawisz F12 (o ile 
nie mamy go zarezerwowanego pod inną funkcjonalność, np. FireBuga).&lt;/li&gt;
&lt;li&gt;Kliknąć w ikonę aparatu fotograficznego, &lt;em&gt;&quot;Zrzut ekranu całej strony&quot;&lt;/em&gt;,
znajdującą się na pasku narzędzi dla programistów.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Jeśli nie możesz znaleźć na pasku narzędzi dla programistów ww. ikony aparatu 
fotograficznego oznacza to najprawdopodobniej że masz ją ukrytą. Aby to sprawdzić
należy wybrać znajdującą się na tym samym pasku ikonę koła zębatego, &lt;em&gt;&quot;Ustawienia
narzędzi&quot;&lt;/em&gt; i upewnić się że w sekcji &lt;em&gt;&quot;Przyciski narzędzi dla programistów&quot;&lt;/em&gt; 
zaznaczona jest opcja &lt;em&gt;&quot;Zrzut ekranu całej strony&quot;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Po kliknięciu w ikonę aparatu zrzut od razu powinien zapisać się w domyślnym 
katalogu do którego FireFox zapisuje pobrane pliki.&lt;/p&gt;

&lt;p&gt;Opisane rozwiązanie jest bardzo wygodne, przeglądarka FF działa zarówno na systemach
Windows, jak i Linuks. Ponad to nie wymaga ono instalowania dodatkowych narzędzi
gdy działamy na systemie już wyposażonym w FF, co może być kluczowe gdy nie mamy
odpowiednich uprawnień by instalować dodatkowe oprogramowanie na danym systemie.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-09-02T19:20:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/09/02/jak-zrobic-zrzut-ekranu-calej-strony-internetowej.html</link>
            <atom:link href="http://lion.net.pl/2016/09/02/jak-zrobic-zrzut-ekranu-calej-strony-internetowej.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/09/02/jak-zrobic-zrzut-ekranu-calej-strony-internetowej.html</guid>
        </item>
                <item>
            <title>Recenzja &#039;JavaScript. Programowanie obiektowe&#039;</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>JS</category>
                        <category>OOP</category>
                        <category>QA</category>
                                    <content:encoded>&lt;p&gt;W tym wpisie chciałbym przedstawić Ci moją opinię o najlepszej książce na temat
JavaScriptu jaką miałem przyjemność przeczytać, czyli o &lt;em&gt;&quot;JavaScript. Programowanie
obiektowe&quot;&lt;/em&gt; napisanej przez &lt;a href=&quot;http://www.phpied.com/&quot;&gt;Stoyana Stefanova&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;javascript-trudny-j%C4%99zyk-jest&quot;&gt;JavaScript trudny język jest&lt;/h3&gt;

&lt;p&gt;JavaScript istnieje już ponad 20 lat. Powstał po to by dodać trochę interakcji
na stronach WWW końca lat 90. Jak każda technologia, tak samo i JS ewoluował.
Początki były trudne, przypominające epokę kamienia łupanego. Ktoś tam coś wymyślił,
jakieś nowe zastosowanie dla JS, a następnie rozlewało się to po całym Internecie,
atakując Nas na niemal każdej odwiedzanej stronie. Gotowe &quot;wstawki&quot; kopiowane były
przez osoby zupełnie nie rozumiejące co kopiują i jak to działa, byle osiągnąć
zamierzony bajerancki efekt na stronie. Nikt raczej nie uczył się JS. Niby w 
książkach o HTML można czasem było znaleźć 2-3 słowa na jego temat, ale głównie 
dlatego że konkurencyjne publikacje wprowadziły taki trend, a nie dlatego że sam
autor chciał się bardzo w ten temat zagłębiać.&lt;/p&gt;

&lt;p&gt;Powstawały kolejne biblioteki i frameworki JS. Dochodziło do takich kuriozum, że
programista chwalący się znajomością JS, aby pobrać jeden głupi element ze strony 
po jego id musiał ładować całą kilkuset-bajtową bibliotekę jQuery...&lt;/p&gt;

&lt;p&gt;Na szczęście te czasy powoli mijają, programiści (i firmy ich zatrudniające) chcą
być bardziej profesjonalni i wiedzieć więcej. Powstają nawet takie specjalizacje
jak &quot;Frontend  Developer&quot;. Coraz więcej osób chce wiedzieć co programuje w JS i 
jak to w rzeczywistości działa. Chcą korzystać z doświadczenia innych, sami szukają
najlepszych praktyk. Jeśli i Ty jesteś taką osobą to książka &lt;em&gt;&quot;JavaScript. 
Programowanie obiektowe&quot;&lt;/em&gt; powinna Cię zainteresować.&lt;/p&gt;

&lt;h3 id=&quot;dla-kogo-jest-ta-ksi%C4%85%C5%BCka%3F&quot;&gt;Dla kogo jest ta książka?&lt;/h3&gt;

&lt;h4 id=&quot;pocz%C4%85tkuj%C4%85cy-programi%C5%9Bci&quot;&gt;Początkujący programiści&lt;/h4&gt;

&lt;p&gt;Początkujący programiści webowi w książce Stefanova znajdą na prawdę fajne, 
obszerne wprowadzenie do tego języka. Stoyan opisuje po kolei każdy z podstawowych
typów dostępnych w JS, przedstawia nam zastosowanie dla wielu wbudowanych funkcji
oraz wprowadza w obiektowość zaimplementowaną w JS.&lt;/p&gt;

&lt;p&gt;Autor w książce pokazuje początkującym jak używać konsoli przeglądarki do szybkiego 
prototypowania i debugowania skryptów. Dowiesz się także co-nieco o środowisku
przeglądarki i zdarzeniach w JS.&lt;/p&gt;

&lt;p&gt;Jeśli zaczynasz przygodę z JS, a lubisz poczytać na papierze i mieć wszystko 
opisane zwięźle i w jednym miejscu, to bierz tą książkę w ciemno.&lt;/p&gt;

&lt;h4 id=&quot;zaawansowani-odbiorcy&quot;&gt;Zaawansowani odbiorcy&lt;/h4&gt;

&lt;p&gt;Mniej więcej połowa książki to podstawy. Oznacza to że druga połowa to już wyższy
poziom wtajemniczenia, wymagający trochę więcej czasu na przetrawienie. Warto 
jednak poświęcić ten czas i nawet przeczytać te kolejne rozdziały po kilka razy 
aż zajarzysz o co chodzi. Autor książki wprowadzi Cię w temat pisania własnych
obiektowych aplikacji w JS. Poznasz 12 wzorców implementacji dziedziczenia w JS!
Jeśli po przeczytaniu poprzedniego zdania oczy otworzyły Ci się szerzej bądź 
opadła Ci szczęka, to nie dziwię się. Także byłem pod wrażeniem. Zrozumienie
przykładów zaproponowanych w książce wymaga wytężenia umysły, zwłaszcza gdy już
jesteś przyzwyczajony do innego rozumienia dziedziczenia, wyniesionego z nauki 
innego języka programowania. Ale gdy już zrozumiesz będziesz mógł być z siebie 
dumny.&lt;/p&gt;

&lt;h3 id=&quot;czego-nie-znajdziesz-w-%22javascript.-programowanie-obiektowe%22&quot;&gt;Czego nie znajdziesz w &quot;JavaScript. Programowanie obiektowe&quot;&lt;/h3&gt;

&lt;p&gt;Recenzowana książka na pewno nie jest dla tych którzy szukają repozytorium gotowych
&quot;wstawek&quot; na stronę WWW. Nie znajdziesz tu także opisu żadnej biblioteki ani 
frameworka. To dobrze.&lt;/p&gt;

&lt;p&gt;W książce brakuje, moim zdaniem, opisu pewnych ogólnych wzorców projektowych JS.
Gdyby zostały one zamieszczone to śmiało mógłbym powiedzieć że do nauki JavaScript
nie potrzebujesz już niczego więcej.&lt;/p&gt;

&lt;p&gt;Publikacja nie zawiera także w sobie ani słowa o standardach pisania w JS oraz
testowaniu kodu JS - ale to być może już temat na inną książkę?&lt;/p&gt;

&lt;h3 id=&quot;kupowa%C4%87-czy-nie%3F&quot;&gt;Kupować czy nie?&lt;/h3&gt;

&lt;p&gt;Moim zdaniem, &lt;strong&gt;warto mieć w swojej programistycznej biblioteczce książkę &lt;em&gt;&quot;Javascript.
Programowanie obiektowe&quot;&lt;/em&gt;&lt;/strong&gt;, zwłaszcza gdy na co dzień zajmujesz się webdevem. 
Jak wiele książek z cyklu &lt;em&gt;&quot;Technologie i rozwiązania&quot;&lt;/em&gt; wydawnictwa Helion, 
książka Stoyana Stefanova prezentuje wysoki poziom oraz bez owijania w bawełnę 
uczy jak pisać dobre oprogramowanie.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Zobacz także:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/05/typy-wyjatkow-w-javascript.html&quot;&gt;Typy wyjątków w JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/05/19/nie-uzywaj-string-number-boolean-jako-konstruktorow-w-javascript.html&quot;&gt;Nie używaj String&amp;#124;Numer&amp;#124;Boolean jako konstruktorów w JavaScript!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/03/24/walidacja-w-akcesorach-javascript.html&quot;&gt;Walidacja w akcesorach JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
            <pubDate>2016-08-07T19:20:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/08/07/recenzja-javascript-programowanie-obiektowe.html</link>
            <atom:link href="http://lion.net.pl/2016/08/07/recenzja-javascript-programowanie-obiektowe.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/08/07/recenzja-javascript-programowanie-obiektowe.html</guid>
        </item>
                <item>
            <title>Wpływ wstępnej filtracji na segmentację wododziałową</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>GKIRO</category>
                                    <content:encoded>&lt;p&gt;W trzecim, a zarazem ostatnim, wpisie z cyklu związanego z moimi badaniami wpływu
wstępnej filtracji obrazu na jego segmentację przedstawię wyniki jakie udało się
mi zaobserwować i płynące z nich wnioski.&lt;/p&gt;

&lt;h3 id=&quot;badanie-wp%C5%82ywu-wst%C4%99pnej-filtracji-obrazu-na-ilo%C5%9B%C4%87-segment%C3%B3w-po-segmentacji&quot;&gt;Badanie wpływu wstępnej filtracji obrazu na ilość segmentów po segmentacji&lt;/h3&gt;

&lt;p&gt;W części badawczej pracy postanowiono przeprowadzić analizę wpływu zastosowanych 
wstępnych filtrów na ilość segmentów na obrazie po segmentacji wododziałowej. 
Przebadano następujące filtry:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;erozja, parametrem jest ilość iteracji&lt;/li&gt;
&lt;li&gt;dylacja, parametrem jest ilość iteracji&lt;/li&gt;
&lt;li&gt;otwarcie, parametrem jest ilość iteracji erozji i dylacji, oraz rozmiar elementu strukturalnego&lt;/li&gt;
&lt;li&gt;zamknięcie, parametrem jest ilość iteracji erozji i dylacji, oraz rozmiar elementu strukturalnego&lt;/li&gt;
&lt;li&gt;otwarcie i zamknięcie, parametrem jest ilość iteracji erozji i dylacji, oraz rozmiar elementu strukturalnego&lt;/li&gt;
&lt;li&gt;filtr medianowy, parametrem jest rozmiar okna&lt;/li&gt;
&lt;li&gt;filtr rozmyty, parametrem jest próg podobieństwa&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ponadto powtórzono badania dla obrazu po zastosowaniu wyrównania histogramu.&lt;/p&gt;

&lt;p&gt;Badania przeprowadzono na &lt;a href=&quot;https://www.flickr.com/photos/bc_the_path/3234972460/&quot;&gt;obrazie RTG przedstawiającym dysplazję w postaci 
torbieli okołowierzchołkowej&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Badania rozpoczęto od wykonania segmentacji na obrazie nie poddawanym wcześniej 
żadnym filtracjom, rysunek 1. W tym przypadku na obrazie 
zliczono &lt;strong&gt;30919&lt;/strong&gt; segmentów. Sprawdzono także wpływ samego wyrównania histogramu 
na ilość segmentów, w wyniku otrzymano obraz z &lt;strong&gt;30196&lt;/strong&gt; segmentami.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/bez_filtracji.jpg&quot; 
        alt=&quot;Wynik segmentacji obrazu bez wstępnej filtracji&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 1: Wynik segmentacji obrazu bez wstępnej filtracji
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;podstawowe-przekszta%C5%82cenia-morfologiczne---erozja-i-dylacja&quot;&gt;Podstawowe przekształcenia morfologiczne - erozja i dylacja&lt;/h4&gt;

&lt;p&gt;Badania postanowiono rozpocząć od sprawdzenia wpływu podstawowych filtrów 
morfologicznych - erozji i dylacji - na ilość segmentów w obrazie po segmentacji 
wododziałowej. Przyjęto kształt elementu strukturalnego jako kwadrat o boku 
równym 3, z punktem odniesienia ustawionym pośrodku. Jako parametr postanowiono 
przyjąć ilość wywołań filtru na obrazie wejściowym. Wyniki przedstawiono w 
tabelach 1, 2, 3, 4. Graficzną interpretację wyników pokazano na rysunku 2. Na 
wykresie można zauważyć, że zarówno w przypadku zastosowania erozji jak i dylacji, 
uzyskano ponad dwukrotne zmniejszenie ilości segmentów już przy pierwszej iteracji. 
Ilość segmentów spada wraz z kolejnymi iteracjami w podobnym tempie dla erozji i 
dylacji. Wyrównanie histogramu przynosi zawsze jedynie niewielki spadek ilości 
segmentów. Oba filtry, wraz z kolejnymi iteracjami powodują coraz większe zmiany 
w kształcie wyodrębnianych segmentów. Jest to zwłaszcza widoczne na granicy 
pomiędzy obserwowaną zmianą chorobową, której kolor jest ciemny, a korzeniem 
zęba przy którym zmiana się ta znajduje, który jest jasny. W przypadku dylacji 
jasne segmenty w obrębie korzenia poszerzają się nachodząc na obszar pierwotnie 
rozpoznawany jako lezja. Jest to spowodowane tym, że dylacja działa jak filtr 
maksymalny. W przypadku erozji obserwowany efekt jest odwrotny, segmenty mające 
reprezentować korzeń zostają zmniejszone, a w ich miejsce narastają segmenty 
reprezentujące lezje. Dzieje się tak ponieważ erozja działa jak filtr minimalny. 
Uzyskane wyniki badań wskazują, że w przypadku dylacji liczba segmentów jest 
mniejsza niż przy tej samej ilości iteracji dla erozji. Dzieje się tak, ponieważ 
w przypadku dylacji dochodzi do złączenia regionów o podobnych poziomach szarości, 
pomiędzy którymi występowały niewielkie regiony o odcieniach szarości mniejszych.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 1: Erozja - ilość segmentów w zależności od ilości iteracji, bez 
        wyrównania histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/th&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;1&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;11313&lt;/td&gt;
            &lt;td&gt;6294&lt;/td&gt;
            &lt;td&gt;4070&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 2: Erozja - ilość segmentów w zależności od ilości iteracji, z 
        wyrównaniem histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;1&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;10957&lt;/td&gt;
            &lt;td&gt;6042&lt;/td&gt;
            &lt;td&gt;3911&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 3: Dylacja - ilość segmentów w zależności od ilości iteracji, bez 
        wyrównania histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;1&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;13238&lt;/td&gt;
            &lt;td&gt;7900&lt;/td&gt;
            &lt;td&gt;5150&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 4: Dylacja - ilość segmentów w zależności od ilości iteracji, z 
        wyrównaniem histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;1&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;12827&lt;/td&gt;
            &lt;td&gt;7644&lt;/td&gt;
            &lt;td&gt;4929&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/badania_podstawowe_filtry_morfologiczne.png&quot; 
        alt=&quot;Podstawowe przekształcenia morfologiczne - erozja i dylacja - zależność ilości segmentów od ilości iteracji&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 2: Podstawowe przekształcenia morfologiczne - erozja i dylacja - 
        zależność ilości segmentów od ilości iteracji
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;z%C5%82o%C5%BCone-przekszta%C5%82cenia-morfologiczne---otwarcie-i-zamkni%C4%99cie&quot;&gt;Złożone przekształcenia morfologiczne - otwarcie i zamknięcie&lt;/h4&gt;

&lt;p&gt;Kolejnym krokiem po przebadaniu podstawowych filtrów morfologicznych była analiza 
skutków połączenia tych filtrów w bardziej złożone algorytmy. Przeprowadzono 
badania dla otwarcia, zamknięcia oraz połączenia tych filtrów.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 5: Otwarcie - ilość segmentów w zależności od ilości iteracji i 
        rozmiaru elementu strukturalnego, bez wyrównania histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;2&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;14569&lt;/td&gt;
            &lt;td&gt;8616&lt;/td&gt;
            &lt;td&gt;5693&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;8616&lt;/td&gt;
            &lt;td&gt;4025&lt;/td&gt;
            &lt;td&gt;2380&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 6: Otwarcie - ilość segmentów w zależności od ilości iteracji i 
        rozmiaru elementu strukturalnego, z wyrównaniem histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col span=&quot;1&quot; style=&quot;width: 20%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;2&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;14102&lt;/td&gt;
            &lt;td&gt;8310&lt;/td&gt;
            &lt;td&gt;5477&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;8300&lt;/td&gt;
            &lt;td&gt;3843&lt;/td&gt;
            &lt;td&gt;2222&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/badania_otwarcie.png&quot; 
        alt=&quot;Złożone przekształcenia morfologiczne - otwarcie - zależność ilości segmentów od ilości iteracji&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 3: Złożone przekształcenia morfologiczne - otwarcie - zależność 
        ilości segmentów od ilości iteracji
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;W tabelach 5 i 6 zawarto wartości ilości zliczonych segmentów po zastosowaniu 
operacji otwarcia morfologicznego. Na rysunku 3 pokazano te wyniki w postaci 
wykresu. Można zauważyć, że dla otwarcia z elementem strukturalnym o rozmiarze 
3x3, wyniki są porównywalne do wyników otrzymanych dla podstawowych filtrów 
morfologicznych, gdzie zastosowano element strukturalny o tym samym rozmiarze. 
Po zmianie rozmiaru elementu strukturalnego na 5x5, zauważono dwukrotny spadek 
ilości segmentów na obrazie wyjściowym. W przypadku otwarcia problem zmiany 
kształtu segmentów granicznych pomiędzy lezją a jej otoczeniem, nie jest tak 
duży jak w przypadku podstawowych filtrów morfologicznych, zwłaszcza dla elementu 
strukturalnego 3x3 i pierwszej iteracji elementem 5x5. Spowodowane jest to tym, 
że operacja otwarcie jest złożeniem operacji erozji i dylacji. Operacja otwarcia 
powoduje usunięcie niewielkich ciemniejszych obszarów z otoczenia większych 
jasnych obszarów.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 7: Zamknięcie - ilość segmentów w zależności od ilości iteracji i 
        rozmiaru elementu strukturalnego, bez wyrównania histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;2&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;10463&lt;/td&gt;
            &lt;td&gt;5892&lt;/td&gt;
            &lt;td&gt;3846&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;5892&lt;/td&gt;
            &lt;td&gt;2698&lt;/td&gt;
            &lt;td&gt;1654&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 8: Zamknięcie - ilość segmentów w zależności od ilości iteracji i 
        rozmiaru elementu strukturalnego, z wyrównaniem histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;2&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;10105&lt;/td&gt;
            &lt;td&gt;5687&lt;/td&gt;
            &lt;td&gt;3729&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;5715&lt;/td&gt;
            &lt;td&gt;2590&lt;/td&gt;
            &lt;td&gt;1578&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/badania_zamkniecie.png&quot; 
        alt=&quot;Złożone przekształcenia morfologiczne - zamknięcie - zależność ilości segmentów od ilości iteracji&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 4: Złożone przekształcenia morfologiczne - zamknięcie - zależność 
        ilości segmentów od ilości iteracji
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;W tabelach 7 i 8 zawarto wartości ilości zliczonych segmentów po zastosowaniu 
operacji zamknięcia morfologicznego. Na rysunku 4 pokazano te wyniki w postaci 
wykresu. Można zauważyć, że ilość segmentów jest mniejsza od ilości otrzymanej 
w wyniku zastosowania otwarcia. Również w tym przypadku problem zmiany kształtu 
segmentów granicznych został ograniczony. Spowodowane to jest także tym, że 
operacja zamknięcia jest złożeniem erozji i dylacji, jednak w odwrotnej 
kolejności wykonywania tych operacji składowych. Segmentów jest mniej ponieważ 
najpierw wykonywana jest dylacja, która sama daje już mniejszą ilość segmentów 
niż erozja, a następnie na obrazie pośrednim wykonywana jest erozja.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 9: Otwarcie + zamknięcie - ilość segmentów w zależności od ilości 
        iteracji i rozmiaru elementu strukturalnego, bez wyrównania histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;2&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;6542&lt;/td&gt;
            &lt;td&gt;3179&lt;/td&gt;
            &lt;td&gt;1879&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;3179&lt;/td&gt;
            &lt;td&gt;1259&lt;/td&gt;
            &lt;td&gt;709&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 10: Otwarcie + zamknięcie - ilość segmentów w zależności od ilości 
        iteracji i rozmiaru elementu strukturalnego, z wyrównaniem histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;3&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;2&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;6350&lt;/td&gt;
            &lt;td&gt;3070&lt;/td&gt;
            &lt;td&gt;1813&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;3070&lt;/td&gt;
            &lt;td&gt;1211&lt;/td&gt;
            &lt;td&gt;676&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/badania_otwarcie_zamkniecie.png&quot; 
        alt=&quot;Złożone przekształcenia morfologiczne - otwarcie i zamknięcie - zależność ilości segmentów od ilości iteracji&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 5: Złożone przekształcenia morfologiczne - otwarcie i zamknięcie 
        - zależność ilości segmentów od ilości iteracji
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Postanowiono także przetestować działanie złożenia operacji otwarcia i zamknięcia. 
Wyniki testów umieszczono w tabelach 9 i 10, a ich wizualizację pokazano na 
rysunku 5. Uzyskano jeszcze większe ograniczenie ilości segmentów. Zastosowanie 
elementu strukturalnego 5x5 powoduje powstanie dużych segmentów i utratę 
informacji o kształcie torbieli. Podobne wyniki uzyskuje się dla elementu 
strukturalnego 3x3 przy dużej ilości iteracji. Jedynie po jednokrotnym 
zastosowaniu tego filtru otrzymane wyniki zachowują rozpoznawany kształt torbieli 
i korzenia.&lt;/p&gt;

&lt;h4 id=&quot;filtr-medianowy&quot;&gt;Filtr medianowy&lt;/h4&gt;

&lt;p&gt;Ze zbioru uśredniających filtrów kontekstowych wybrano filtr medianowy. W tabelach
11 i 12 pokazano wyniki, a ich reprezentację graficzną umieszczono na rysunku 6. 
Można zauważyć, że otrzymane wielkości są porównywalne do wartości otrzymanych 
poprzednio dla złożonych filtrów morfologicznych. Wraz z zwiększaniem ilości 
iteracji, zachowując ten sam rozmiar okna otrzymuje się coraz mniej segmentów. 
Różnice te są jednak coraz mniejsze. Zwiększanie wielkości okna powoduje 
zmniejszenie ilości segmentów przy tej samej ilości iteracji. W tym przypadku 
także zwiększanie okna powoduje coraz mniejsze różnice w wynikach. W przypadku 
filtru medianowego problem zmiany kształtu segmentów granicznych nie jest 
widoczny nawet na obrazach poddanych wielu iteracjom, także tym gdzie rozmiar 
okna był większy. Granica pomiędzy torbielą, a korzeniem jest dobrze zaznaczona, 
wyostrzyła się. Na rysunku 7 pokazano wynik segmentacji obrazu po wstępnej 
filtracji filtrem medianowym o oknie 3x3, pięcioma iteracjami.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 11: Filtr medianowy - ilość segmentów w zależności od ilości 
        iteracji i rozmiaru okna, bez wyrównania histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;5&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
            &lt;th&gt;4&lt;/th&gt;
            &lt;th&gt;5&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;3&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;12215&lt;/td&gt;
            &lt;td&gt;8484&lt;/td&gt;
            &lt;td&gt;7515&lt;/td&gt;
            &lt;td&gt;6947&lt;/td&gt;
            &lt;td&gt;6664&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;7655&lt;/td&gt;
            &lt;td&gt;4752&lt;/td&gt;
            &lt;td&gt;4036&lt;/td&gt;
            &lt;td&gt;3551&lt;/td&gt;
            &lt;td&gt;3303&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;7x7&lt;/th&gt;
            &lt;td&gt;5740&lt;/td&gt;
            &lt;td&gt;3440&lt;/td&gt;
            &lt;td&gt;2830&lt;/td&gt;
            &lt;td&gt;2510&lt;/td&gt;
            &lt;td&gt;2283&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 12: Filtr medianowy - ilość segmentów w zależności od ilości 
        iteracji i rozmiaru okna, z wyrównaniem histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;5&quot;&gt;Ilość iteracji&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
            &lt;th&gt;4&lt;/th&gt;
            &lt;th&gt;5&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;3&quot;&gt;Rozmiar elementu strukturalnego&lt;/th&gt;
            &lt;th&gt;3x3&lt;/th&gt;
            &lt;td&gt;11784&lt;/td&gt;
            &lt;td&gt;8202&lt;/td&gt;
            &lt;td&gt;7241&lt;/td&gt;
            &lt;td&gt;6727&lt;/td&gt;
            &lt;td&gt;6449&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5x5&lt;/th&gt;
            &lt;td&gt;7420&lt;/td&gt;
            &lt;td&gt;4665&lt;/td&gt;
            &lt;td&gt;3922&lt;/td&gt;
            &lt;td&gt;3462&lt;/td&gt;
            &lt;td&gt;3213&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;7x7&lt;/th&gt;
            &lt;td&gt;5621&lt;/td&gt;
            &lt;td&gt;3327&lt;/td&gt;
            &lt;td&gt;2766&lt;/td&gt;
            &lt;td&gt;2427&lt;/td&gt;
            &lt;td&gt;2187&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/badania_mediana.png&quot; 
        alt=&quot;Filtr medianowy - zależność ilości segmentów od ilości iteracji&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 6: Filtr medianowy - zależność ilości segmentów od ilości iteracji
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/filtr_medianowy_w3x3_x5.jpg&quot; 
        alt=&quot;Wynik segmentacji obrazu po wstępnej filtracji filtrem medianowym o oknie 3x3, pięcioma iteracjami&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 7: Wynik segmentacji obrazu po wstępnej filtracji filtrem 
        medianowym o oknie 3x3, pięcioma iteracjami
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;filtr-rozmyty&quot;&gt;Filtr rozmyty&lt;/h4&gt;

&lt;p&gt;Ostatnim testowanym filtrem był filtr rozmyty zaimplementowany według opisu 
umieszczonego we &lt;a href=&quot;/2016/07/03/przeksztalcenia-morfologiczne-kontekstowe-i-rozmyte.html&quot;&gt;wpisie wprowadzającym&lt;/a&gt;. Otrzymane wyniki pokazano w tabelach
13 i 14 oraz na rysunku 8. Parametrem dla którego badano wpływ jego zmian na 
ilość segmentów był próg podobieństwa, czyli wartość różnicy pomiędzy wartościami 
dwóch sąsiadujących pikseli po przekroczeniu której para ta była uznawana za 
niepodobną. Ponieważ wynik działania filtru ma charakter losowy, dla każdej 
wartości progu podobieństwa przeprowadzono pięć prób, po czym obliczono średnie 
wartości oraz rozrzut wokół wartości średniej. Okazało się, że filtr 
charakteryzuje się dużą stabilnością otrzymywanych wyników. Z otrzymanego wykresu 
wynika, że najmniej segmentów otrzymuje się dla wartości progu podobieństwa 
mieszczących się pomiędzy 5 a 10. Dla wartości mniejszych ilość segmentów jest 
największa, a dla wartości większych rośnie i stabilizuje się. Otrzymane minimalne 
wartości są trzy razy mniejsze niż w przypadku braku filtracji. Podobnie jak w 
przypadku filtru medianowego, nie występuje problem zmiany kształtu granic 
oddzielających torbiel od otoczenia. Na rysunku 9 pokazano wynik segmentacji 
obrazu po wstępnej filtracji filtrem rozmytym z progiem podobieństwa 8px.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 13: Filtr rozmyty - ilość segmentów w zależności od progu 
        podobieństwa i próby, bez wyrównania histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;7&quot;&gt;Próg podobieństwa&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;5&lt;/th&gt;
            &lt;th&gt;8&lt;/th&gt;
            &lt;th&gt;10&lt;/th&gt;
            &lt;th&gt;20&lt;/th&gt;
            &lt;th&gt;30&lt;/th&gt;
            &lt;th&gt;40&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;5&quot;&gt;Próba&lt;/th&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;td&gt;9894&lt;/td&gt;
            &lt;td&gt;10089&lt;/td&gt;
            &lt;td&gt;9747&lt;/td&gt;
            &lt;td&gt;9865&lt;/td&gt;
            &lt;td&gt;9974&lt;/td&gt;
            &lt;td&gt;9944&lt;/td&gt;
            &lt;td&gt;9967&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;td&gt;9858&lt;/td&gt;
            &lt;td&gt;10101&lt;/td&gt;
            &lt;td&gt;9782&lt;/td&gt;
            &lt;td&gt;9893&lt;/td&gt;
            &lt;td&gt;9939&lt;/td&gt;
            &lt;td&gt;9967&lt;/td&gt;
            &lt;td&gt;9945&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;3&lt;/th&gt;
            &lt;td&gt;9881&lt;/td&gt;
            &lt;td&gt;10137&lt;/td&gt;
            &lt;td&gt;9784&lt;/td&gt;
            &lt;td&gt;9886&lt;/td&gt;
            &lt;td&gt;9956&lt;/td&gt;
            &lt;td&gt;9976&lt;/td&gt;
            &lt;td&gt;9955&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;4&lt;/th&gt;
            &lt;td&gt;9880&lt;/td&gt;
            &lt;td&gt;10071&lt;/td&gt;
            &lt;td&gt;9808&lt;/td&gt;
            &lt;td&gt;9860&lt;/td&gt;
            &lt;td&gt;10001&lt;/td&gt;
            &lt;td&gt;9973&lt;/td&gt;
            &lt;td&gt;9943&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5&lt;/th&gt;
            &lt;td&gt;9983&lt;/td&gt;
            &lt;td&gt;10051&lt;/td&gt;
            &lt;td&gt;9772&lt;/td&gt;
            &lt;td&gt;9830&lt;/td&gt;
            &lt;td&gt;9951&lt;/td&gt;
            &lt;td&gt;9986&lt;/td&gt;
            &lt;td&gt;9959&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Średnia&lt;/th&gt;
            &lt;td&gt;9899,2&lt;/td&gt;
            &lt;td&gt;10089,8&lt;/td&gt;
            &lt;td&gt;9778,6&lt;/td&gt;
            &lt;td&gt;9866,8&lt;/td&gt;
            &lt;td&gt;9964,2&lt;/td&gt;
            &lt;td&gt;9969,2&lt;/td&gt;
            &lt;td&gt;9953,8&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Odchylenie standardowe&lt;/th&gt;
            &lt;td&gt;48,60&lt;/td&gt;
            &lt;td&gt;32,45&lt;/td&gt;
            &lt;td&gt;22,06&lt;/td&gt;
            &lt;td&gt;24,79&lt;/td&gt;
            &lt;td&gt;24,12&lt;/td&gt;
            &lt;td&gt;15,67&lt;/td&gt;
            &lt;td&gt;9,96&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 14: Filtr rozmyty - ilość segmentów w zależności od progu 
        podobieństwa i próby, z wyrównaniem histogramu
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;7&quot;&gt;Próg podobieństwa&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;5&lt;/th&gt;
            &lt;th&gt;8&lt;/th&gt;
            &lt;th&gt;10&lt;/th&gt;
            &lt;th&gt;20&lt;/th&gt;
            &lt;th&gt;30&lt;/th&gt;
            &lt;th&gt;40&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;5&quot;&gt;Próba&lt;/th&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;td&gt;10457&lt;/td&gt;
            &lt;td&gt;10072&lt;/td&gt;
            &lt;td&gt;10060&lt;/td&gt;
            &lt;td&gt;10067&lt;/td&gt;
            &lt;td&gt;10294&lt;/td&gt;
            &lt;td&gt;10199&lt;/td&gt;
            &lt;td&gt;10238&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;td&gt;10527&lt;/td&gt;
            &lt;td&gt;10103&lt;/td&gt;
            &lt;td&gt;10043&lt;/td&gt;
            &lt;td&gt;10046&lt;/td&gt;
            &lt;td&gt;10229&lt;/td&gt;
            &lt;td&gt;10216&lt;/td&gt;
            &lt;td&gt;10192&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;3&lt;/th&gt;
            &lt;td&gt;10595&lt;/td&gt;
            &lt;td&gt;10107&lt;/td&gt;
            &lt;td&gt;10016&lt;/td&gt;
            &lt;td&gt;10000&lt;/td&gt;
            &lt;td&gt;10165&lt;/td&gt;
            &lt;td&gt;10212&lt;/td&gt;
            &lt;td&gt;10187&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;4&lt;/th&gt;
            &lt;td&gt;10503&lt;/td&gt;
            &lt;td&gt;10091&lt;/td&gt;
            &lt;td&gt;10024&lt;/td&gt;
            &lt;td&gt;10028&lt;/td&gt;
            &lt;td&gt;10231&lt;/td&gt;
            &lt;td&gt;10213&lt;/td&gt;
            &lt;td&gt;10187&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5&lt;/th&gt;
            &lt;td&gt;10518&lt;/td&gt;
            &lt;td&gt;10120&lt;/td&gt;
            &lt;td&gt;10013&lt;/td&gt;
            &lt;td&gt;10002&lt;/td&gt;
            &lt;td&gt;10246&lt;/td&gt;
            &lt;td&gt;10218&lt;/td&gt;
            &lt;td&gt;10197&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Średnia&lt;/th&gt;
            &lt;td&gt;10520,0&lt;/td&gt;
            &lt;td&gt;10098,6&lt;/td&gt;
            &lt;td&gt;10031,2&lt;/td&gt;
            &lt;td&gt;10028,6&lt;/td&gt;
            &lt;td&gt;10233,0&lt;/td&gt;
            &lt;td&gt;10211,6&lt;/td&gt;
            &lt;td&gt;10200,2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Odchylenie standardowe&lt;/th&gt;
            &lt;td&gt;49,84&lt;/td&gt;
            &lt;td&gt;18,12&lt;/td&gt;
            &lt;td&gt;19,89&lt;/td&gt;
            &lt;td&gt;28,74&lt;/td&gt;
            &lt;td&gt;46,19&lt;/td&gt;
            &lt;td&gt;7,44&lt;/td&gt;
            &lt;td&gt;21,53&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/badania_fuzzy.png&quot; 
        alt=&quot;Filtr rozmyty - zależność ilości segmentów od ilości iteracji&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 8: Filtr rozmyty - zależność ilości segmentów od ilości iteracji
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/badania/filtr_rozmyty_t8.jpg&quot; 
        alt=&quot;Wynik segmentacji obrazu po filtracji filtrem rozmytym z progiem podobieństwa 8px&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 9: Wynik segmentacji obrazu po filtracji filtrem rozmytym z 
        progiem podobieństwa 8px
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;badanie-wp%C5%82ywu-wst%C4%99pnej-filtracji-obrazu-na-czas-wykonania-procesu-segmentacji&quot;&gt;Badanie wpływu wstępnej filtracji obrazu na czas wykonania procesu segmentacji&lt;/h3&gt;

&lt;p&gt;Postanowiono zbadać czas wykonania procesu dla dwóch wybranych najlepszymi filtrów 
- filtru medianowego z oknem 3x3 i pięcioma iteracjami oraz dla filtru rozmytego 
z progiem podobieństwa ustawionym na 10 pikseli. Oba filtry zostały poprzedzone 
wyrównaniem histogramu. Postanowiono przeprowadzić po pięć prób dla każdego z 
filtrów. Badania przeprowadzono na tym samym &lt;a href=&quot;https://www.flickr.com/photos/bc_the_path/3234972460/&quot;&gt;obrazie testowym który zastosowano 
w poprzednich badaniach&lt;/a&gt;. Badania przeprowadzono na komputerze wyposażonym w 
procesor Athlon II X2 250 i 4GB pamięci RAM.&lt;/p&gt;

&lt;h4 id=&quot;filtr-medianowy---czas-wykonania-procesu&quot;&gt;Filtr medianowy - czas wykonania procesu&lt;/h4&gt;

&lt;p&gt;W tabeli 15 umieszczono czasy wykonani poszczególnych operacji składających się 
na proces segmentacji, tj.: wstępnej filtracji, segmentacji oraz oznaczania 
segmentów. Operację oznaczania segmentów sprawdzono dla dwóch zaproponowanych 
algorytmów, &lt;em&gt;SegmentMarkerBasic&lt;/em&gt; - powolnego algorytmu polegającego na złączaniu 
segmentów, &lt;em&gt;SegmentMarkerFlooding&lt;/em&gt; - szybkiego algorytmu polegającego na 
sprawdzaniu pikseli sąsiadujących w pierwszej kolejności, algorytmy te zostaną 
opisane w kolejnych wpisach. W tabeli tej podano także całkowity czas wykonania 
procesu. W wyniku, dla obrazu testowego, otrzymano średni całkowity czas równy 
182,33 sekund w przypadku zastosowania algorytmu &lt;em&gt;SegmentMarkerBasic&lt;/em&gt; oraz 1,32 
sekundy w przypadku zastosowania algorytmu &lt;em&gt;SegmentMarkerFlooding&lt;/em&gt;. Operacja 
wykonania filtru medianowego na obrazie miała najmniejszy wpłyn na czas całkowity, 
podobnie operacja segmentacji wododziałowej. Operacja oznaczania segmentów, w 
przypadku wybrania wolniejszego algorytmu ma największy wpływ na całkowity czas 
procesu.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 15: Filtr medianowy - czas wykonania procesu segmentacji
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;6&quot;&gt;Czas [s]&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;filtracja&lt;/th&gt;
            &lt;th&gt;segmentacja&lt;/th&gt;
            &lt;th&gt;oznaczanie segmentów (basic)&lt;/th&gt;
            &lt;th&gt;oznaczanie segmentów (flooding)&lt;/th&gt;
            &lt;th&gt;razem (basic)&lt;/th&gt;
            &lt;th&gt;razem (flooding)&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;5&quot;&gt;Próba&lt;/th&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;td&gt;0,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;172,88&lt;/td&gt;
            &lt;td&gt;0,32&lt;/td&gt;
            &lt;td&gt;173,88&lt;/td&gt;
            &lt;td&gt;1,32&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;td&gt;0,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;166,60&lt;/td&gt;
            &lt;td&gt;0,39&lt;/td&gt;
            &lt;td&gt;167,60&lt;/td&gt;
            &lt;td&gt;1,39&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;3&lt;/th&gt;
            &lt;td&gt;0,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;198,29&lt;/td&gt;
            &lt;td&gt;0,44&lt;/td&gt;
            &lt;td&gt;199,29&lt;/td&gt;
            &lt;td&gt;1,44&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;4&lt;/th&gt;
            &lt;td&gt;0,00&lt;/td&gt;
            &lt;td&gt;2,00&lt;/td&gt;
            &lt;td&gt;199,82&lt;/td&gt;
            &lt;td&gt;0,42&lt;/td&gt;
            &lt;td&gt;201,82&lt;/td&gt;
            &lt;td&gt;2,42&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5&lt;/th&gt;
            &lt;td&gt;0,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;168,05&lt;/td&gt;
            &lt;td&gt;0,30&lt;/td&gt;
            &lt;td&gt;169,05&lt;/td&gt;
            &lt;td&gt;1,30&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Średnia&lt;/th&gt;
            &lt;td&gt;0,00&lt;/td&gt;
            &lt;td&gt;1,20&lt;/td&gt;
            &lt;td&gt;181,13&lt;/td&gt;
            &lt;td&gt;0,37&lt;/td&gt;
            &lt;td&gt;182,33&lt;/td&gt;
            &lt;td&gt;1,57&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Odchylenie standardowe&lt;/th&gt;
            &lt;td&gt;0,00&lt;/td&gt;
            &lt;td&gt;0,45&lt;/td&gt;
            &lt;td&gt;16,54&lt;/td&gt;
            &lt;td&gt;0,06&lt;/td&gt;
            &lt;td&gt;16,82&lt;/td&gt;
            &lt;td&gt;0,48&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;filtr-rozmyty---czas-wykonania-procesu&quot;&gt;Filtr rozmyty - czas wykonania procesu&lt;/h4&gt;

&lt;p&gt;W tabeli 16 umieszczono zmierzone czasy poszczególnych składowych procesu w 
przypadku zastosowania filtru rozmytego. Składowe procesu są takie same jak w 
przypadku filtru medianowego. Wyniki wskazują na wzrost znaczenia czasy potrzebnego 
na filtrację obrazu w całym procesie. Średnio ten czas wynosi 24,40 sekund, co 
jest zauważalnym czasem, zwłaszcza przy zastosowaniu szybkiego algorytmu oznaczania 
segmentów. Jest to także duży wzrost w porównaniu do filtracji medianowej która 
wykonywana była niemal natychmiastowo. Średni czas całego procesu, w przypadku 
zastosowania algorytmu &lt;em&gt;SegmentMarkerBasic&lt;/em&gt; wzrósł do 212,38 sekund, a w przypadku 
algorytmu &lt;em&gt;SegmentMarkerFlooding&lt;/em&gt; czas ten wzrósł do 25,98 sekund.&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;
        Tabela 16: Filtr rozmyty - czas wykonania procesu segmentacji
    &lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style=&quot;width: 20%&quot;&gt;
        &lt;col style=&quot;width: 10%&quot;&gt;
    &lt;/colgroup&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;
            &lt;th colspan=&quot;6&quot;&gt;Czas [s]&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;filtracja&lt;/th&gt;
            &lt;th&gt;segmentacja&lt;/th&gt;
            &lt;th&gt;oznaczanie segmentów (basic)&lt;/th&gt;
            &lt;th&gt;oznaczanie segmentów (flooding)&lt;/th&gt;
            &lt;th&gt;razem (basic)&lt;/th&gt;
            &lt;th&gt;razem (flooding)&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th rowspan=&quot;5&quot;&gt;Próba&lt;/th&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;td&gt;28,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;188,42&lt;/td&gt;
            &lt;td&gt;0,47&lt;/td&gt;
            &lt;td&gt;217,42&lt;/td&gt;
            &lt;td&gt;29,47&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;td&gt;22,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;180,15&lt;/td&gt;
            &lt;td&gt;0,37&lt;/td&gt;
            &lt;td&gt;203,15&lt;/td&gt;
            &lt;td&gt;23,37&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;3&lt;/th&gt;
            &lt;td&gt;23,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;197,79&lt;/td&gt;
            &lt;td&gt;0,37&lt;/td&gt;
            &lt;td&gt;221,79&lt;/td&gt;
            &lt;td&gt;24,37&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;4&lt;/th&gt;
            &lt;td&gt;23,00&lt;/td&gt;
            &lt;td&gt;1,00&lt;/td&gt;
            &lt;td&gt;168,58&lt;/td&gt;
            &lt;td&gt;0,37&lt;/td&gt;
            &lt;td&gt;192,58&lt;/td&gt;
            &lt;td&gt;24,37&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;5&lt;/th&gt;
            &lt;td&gt;26,00&lt;/td&gt;
            &lt;td&gt;2,00&lt;/td&gt;
            &lt;td&gt;198,98&lt;/td&gt;
            &lt;td&gt;0,34&lt;/td&gt;
            &lt;td&gt;226,98&lt;/td&gt;
            &lt;td&gt;28,34&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Średnia&lt;/th&gt;
            &lt;td&gt;24,40&lt;/td&gt;
            &lt;td&gt;1,20&lt;/td&gt;
            &lt;td&gt;186,78&lt;/td&gt;
            &lt;td&gt;0,38&lt;/td&gt;
            &lt;td&gt;212,38&lt;/td&gt;
            &lt;td&gt;25,98&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;Odchylenie standardowe&lt;/th&gt;
            &lt;td&gt;2,51&lt;/td&gt;
            &lt;td&gt;0,45&lt;/td&gt;
            &lt;td&gt;12,73&lt;/td&gt;
            &lt;td&gt;0,05&lt;/td&gt;
            &lt;td&gt;14,18&lt;/td&gt;
            &lt;td&gt;2,73&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;wnioski&quot;&gt;Wnioski&lt;/h3&gt;

&lt;p&gt;Przeprowadzono badania mające na celu wskazanie najlepszego, biorąc pod uwagę 
ilość i jakość otrzymanych segmentów, algorytmu przygotowującego zdjęcie do 
analizy. Wzięto pod uwagę podstawowe filtry morfologiczne, tj.: erozję i dylację, 
złożone filtry morfologiczne, tj.: otwarcie i zamknięcie oraz ich złożenie, 
filtr medianowy oraz filtr wykorzystujący logikę rozmytą. &lt;strong&gt;W wyniku przeprowadzonych 
badań, okazało się że filtry morfologiczne z powodu zmiany kształtu otrzymywanych 
w następstwie ich użycia segmentów granicznych, czyli znajdujących się w miejscach 
o największych zmianach gradientu, nie powinny być wykorzystywane do wstępnej 
filtracji obrazu przed jego segmentacją. Otrzymano dobre wyniki dla filtru 
medianowego o oknie 3x3, dla każdej ze zbadanych ilości iteracji. Filtr ten nie 
powoduje także zmiany kształtu segmentów granicznych. Dobre wyniki przyniosło 
także zastosowanie zaimplementowanego algorytmu wykorzystującego logikę rozmytą&lt;/strong&gt;. 
Przeprowadzono badania polegające na znalezieniu optymalnej wartości progu 
podobieństwa, jednego z parametrów tego algorytmu, dla której ilość segmentów jest 
najmniejsza. Wyznaczono lokalne minimum dla tego parametru, wynoszące 10 pikseli. 
Oznacza to że dla mniejszej i większej wartości progu filtr ten działa gorzej 
nie odnajdując wszystkich zaszumionych pikseli co powoduje wzrost lokalnych 
minimów obrazu a co za tym idzie ilości segmentów.&lt;/p&gt;

&lt;p&gt;Przeprowadzono także badania polegające na zmierzeniu czasu jaki potrzebny jest 
na przeprowadzenie całego procesu segmentacji dla dwóch filtrów: filtru rozmytego 
z progiem 10px oraz filtru medianowego z oknem 3x3 i pięcioma iteracjami. 
Otrzymane wyniki wskazują, że &lt;strong&gt;filtr medianowy jest znacznie szybszy od 
zaimplementowanego filtru rozmytego&lt;/strong&gt;. Jest to spowodowane większą złożonością 
obliczeniową algorytmu rozmytego, a także tym że filtr medianowy pochodził z 
napisanej w C++ i zoptymalizowanej do tego celu biblioteki OpenCV.&lt;/p&gt;

&lt;p&gt;Po przeprowadzeniu badań zdecydowano się zaimplementować w systemie obsługującym 
gabinet dentystyczny algorytm wykorzystujący filtr medianowy z oknem 3x3 i 
pięcioma iteracjami.&lt;/p&gt;

&lt;p&gt;Podczas testów czasu wykonania procesu segmentacji pokazano że największe narzut 
generuje algorytm &lt;em&gt;SegmentMarkerBasic&lt;/em&gt;. Z powodu mogącego się pojawić wyjątku 
generowanego przez alternatywny algorytm został on jednak wybrany i zaimplementowany 
w systemie obsługi gabinetu dentystycznego.&lt;/p&gt;

&lt;p&gt;Zamierzano napisać algorytm pozwalający na zautomatyzowanie procesu oznaczania na 
zdjęciach RTG patologicznych zmian okołowierzchołkowych zęba spowodowanych stanem 
zapalnym. &lt;strong&gt;Napisano algorytm wykorzystujący oznaczone segmenty, ograniczający 
ingerencję użytkownika do wybrania segmentu znajdującego się wewnątrz takiej 
zmiany oraz drugiego poza nią. Algorytm ten wybiera kolejne segmenty biorąc pod 
uwagę średnie wartości pikseli we wskazanych segmentach.&lt;/strong&gt; Nie zawsze jednak wynik 
jego działania jest zgodny z oczekiwaniami. W związku z tym należałoby go 
rozbudować o algorytm działający w sposób adaptacyjny.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Treść tego wpisu zawiera fragmenty mojej pracy dyplomowej &lt;strong&gt;&quot;Badanie wpływu 
wstępnej filtracji na proces segmentacji w analizie patologicznych zmian w 
obrębie zębów widocznych na zdjęciach RTG&quot;&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Zobacz także:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/07/03/przeksztalcenia-morfologiczne-kontekstowe-i-rozmyte.html&quot;&gt;Przekształcenia morfologiczne, kontekstowe i rozmyte&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/07/24/emgucvdemo-aplikacja-testujaca-wplyw-wybranych-filtrow-na-wyniki-segmentacji-wododzialowej.html&quot;&gt;EmguCVDemo - aplikacja testująca wpływ wybranych filtrów na wyniki segmentacji wododziałowej&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
            <pubDate>2016-08-06T15:50:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/08/06/wplyw-wstepnej-filtracji-na-segmentacje-wododzialowa.html</link>
            <atom:link href="http://lion.net.pl/2016/08/06/wplyw-wstepnej-filtracji-na-segmentacje-wododzialowa.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/08/06/wplyw-wstepnej-filtracji-na-segmentacje-wododzialowa.html</guid>
        </item>
                <item>
            <title>EmguCVDemo - aplikacja testująca wpływ wybranych filtrów na wyniki segmentacji wododziałowej</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>GKIRO</category>
                                    <content:encoded>&lt;p&gt;To już drugi post z cyklu badania wpływu wstępnej filtracji na jakość wyników
uzyskanych podczas segmentacji wododziałowej. W poprzednim wpisie mogłeś przeczytać
o &lt;a href=&quot;/2016/07/03/przeksztalcenia-morfologiczne-kontekstowe-i-rozmyte.html&quot;&gt;teorii kryjącej się za filtrami kontekstowymi, morfologicznymi i rozmytymi&lt;/a&gt;, 
będącymi przedmiotem badań. W tym wpisie przedstawię narzędzie pomocnicze
napisane przeze mnie w celu przeprowadzenia badań.&lt;/p&gt;

&lt;h3 id=&quot;analiza-obraz%C3%B3w---biblioteka-emgucv&quot;&gt;Analiza obrazów - biblioteka EmguCV&lt;/h3&gt;

&lt;p&gt;EmguCV jest nakładką na OpenCV Open Computer Vision, pozwalającą na wykorzystywanie
tej biblioteki w środowisku Microsoft .NET Framework. OpenCV (Open Source Computer 
Vision) jest biblioteką zawierającą w sobie wiele (ponad 2500) algorytmów 
wykorzystywanych w grafice komputerowej. Oprogramowanie to jest rozwijane od 
1993 roku przez firmę Intel i od tego czasu pełni ważną rolę w badaniach i 
tworzeniu oprogramowania z zakresu wizji komputerowej. Biblioteka posiada 
interfejsy pozwalające na wykorzystanie jej w językach programowania takich jak 
C, C++, Python i Java. OpenCV działa w systemach MS Windows, Linux, Mac oraz 
Android. Wśród zaimplementowanych w bibliotece algorytmów można odleźć 
przekształcenia punktowe, kontekstowe, morfologiczne, algorytmy segmentacji, 
rozpoznawania obrazów. Biblioteka ta wykorzystywana jest m. in. w analizie obrazów 
na potrzeby bezpieczeństwa, w procesach medycznych, do identyfikacji oraz do 
sterowania robotami. Biblioteka OpenCV udostępniana jest na licencji BSD Berkeley 
Software Distribution License, natomiast EmguCV na licencji GNU GPL General 
Public License v3[&lt;a href=&quot;#opencv&quot;&gt;3&lt;/a&gt;].&lt;/p&gt;

&lt;h3 id=&quot;emgucvdemo---specyfikacja-zewn%C4%99trzna&quot;&gt;EmguCVDemo - specyfikacja zewnętrzna&lt;/h3&gt;

&lt;p&gt;W tym rozdziale przedstawiona zostanie aplikacja pomocnicza EmguCVDemo. Aplikacja 
ta została napisana w celu przygotowania środowiska dla testów przeprowadzanych 
w części badawczej pracy. Środowisko to zapewnia dostęp do algorytmów filtracji 
obrazu dostępnych w bibliotece EmguCV oraz do własnych implementacji wybranych 
algorytmów. Aplikacja może być wykorzystywana do testowania wpływu wybranych 
filtrów na obraz i jego późniejszą segmentację.&lt;/p&gt;

&lt;h4 id=&quot;emgucvdemo&quot;&gt;EmguCVDemo&lt;/h4&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/emgucvdemo.png&quot; alt=&quot;EmguCVDemo - okno programu testowego&quot;&gt;
    &lt;figcaption&gt;Rysunek 1: EmguCVDemo - okno programu testowego&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Na rysunku 1 pokazano główne okno aplikacji EmguCVDemo. Interfejs programu składa 
się z panelu, na którym wyświetlane są zdjęcia, jedno oryginalne - przed obróbką, 
drugie po zastosowaniu dostępnych operacji. Operacje dostępne w programie są za 
pomocą znajdujących się na formatce przycisków lub z poziomu paska zadań programu. 
Do sterowania parametrami niektórych operacji wykorzystuje się kontrolki 
znajdujące się w oknie programu w panelu po lewej stronie. Wśród wykorzystanych 
operacji pochodzących z biblioteki EmguCV można wymienić:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Przekształcenia morfologiczne:

&lt;ul&gt;
&lt;li&gt;Erozja&lt;/li&gt;
&lt;li&gt;Dylacja&lt;/li&gt;
&lt;li&gt;Otwarcie&lt;/li&gt;
&lt;li&gt;Zamknięcie&lt;/li&gt;
&lt;li&gt;White Top Hat&lt;/li&gt;
&lt;li&gt;Black Top Hat&lt;/li&gt;
&lt;li&gt;Gradient morfologiczny&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Przekształcenia kontekstowe:

&lt;ul&gt;
&lt;li&gt;Wyrównanie histogramu&lt;/li&gt;
&lt;li&gt;Filtr medianowy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Inne narzędzia:

&lt;ul&gt;
&lt;li&gt;Negacja obrazu&lt;/li&gt;
&lt;li&gt;Reset obrazu&lt;/li&gt;
&lt;li&gt;Powiększenie&lt;/li&gt;
&lt;li&gt;Pomniejszenie&lt;/li&gt;
&lt;li&gt;Reset rozmiaru&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Wymienione operacje uzupełniono interfejsem do własnych implementacji następujących 
algorytmów:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Przekształcenia logiki rozmytej:

&lt;ul&gt;
&lt;li&gt;Fuzzy Noise Smoothing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Operacje związane z segmentacją:

&lt;ul&gt;
&lt;li&gt;Lokalne minima&lt;/li&gt;
&lt;li&gt;Segmentacja wododziałowa&lt;/li&gt;
&lt;li&gt;Liczenie segmentów&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parametry filtrów dostępne w programie pozwalają na sterowanie rozmiarem elementu 
strukturalnego filtrów morfologicznych, a także położeniem punktu odniesienia w 
jego wnętrzu. Możliwe jest także manipulowanie ilością iteracji.&lt;/p&gt;

&lt;p&gt;Dostępna jest opcja zmiany algorytmu zliczania segmentów z podstawowego 
(&lt;em&gt;SegmentMarkerBasic&lt;/em&gt;) na (&lt;em&gt;SegmentMarkerFlooding&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Możliwe jest także sterowanie rozmiarem okna filtru medianowego.&lt;/p&gt;

&lt;p&gt;Po przeprowadzeniu segmentacji możliwe jest oznaczenie na obrazie wyjściowym 
dwóch segmentów - wewnętrznego i zewnętrznego, po czym następuje wyszukiwanie 
przez algorytm segmentów pośrednich. Pokazano to na rysunku 1, obraz wejściowy 
poddano wstępnej filtracji, segmentacji a następnie zaznaczony czerwony segment 
wewnętrzny i zielony zewnętrzny. Granice segmentów pośrednich oznaczone zostały 
kolorem niebieskim.&lt;/p&gt;

&lt;p&gt;Opcja &lt;em&gt;Liczenie segmentów&lt;/em&gt; pozwala na oznaczenie segmentów i zliczenie ich liczby 
na obrazie. Po zakończonej operacji użytkownik otrzymuje podsumowanie z liczbą 
segmentów oraz czasem zliczania. Wykonanie tej operacji jest niezbędne, aby móc 
oznaczać segmenty na obrazie.&lt;/p&gt;

&lt;h3 id=&quot;literatura&quot;&gt;Literatura&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a name=&quot;wyklady-gkiro&quot;&gt;
    &lt;strong&gt;&lt;em&gt;OpenCV Wiki&lt;/em&gt;.&lt;/strong&gt; http://opencv.willowgarage.com/wiki, 2013
&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Treść tego wpisu zawiera fragmenty mojej pracy dyplomowej &lt;strong&gt;&quot;Badanie wpływu 
wstępnej filtracji na proces segmentacji w analizie patologicznych zmian w 
obrębie zębów widocznych na zdjęciach RTG&quot;&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Zobacz także:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/07/03/przeksztalcenia-morfologiczne-kontekstowe-i-rozmyte.html&quot;&gt;Przekształcenia morfologiczne, kontekstowe i rozmyte&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/08/06/wplyw-wstepnej-filtracji-na-segmentacje-wododzialowa.html&quot;&gt;Wpływ wstępnej filtracji na segmentację wododziałową&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
            <pubDate>2016-07-24T15:10:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/07/24/emgucvdemo-aplikacja-testujaca-wplyw-wybranych-filtrow-na-wyniki-segmentacji-wododzialowej.html</link>
            <atom:link href="http://lion.net.pl/2016/07/24/emgucvdemo-aplikacja-testujaca-wplyw-wybranych-filtrow-na-wyniki-segmentacji-wododzialowej.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/07/24/emgucvdemo-aplikacja-testujaca-wplyw-wybranych-filtrow-na-wyniki-segmentacji-wododzialowej.html</guid>
        </item>
                <item>
            <title>Małe - wielkie zmiany w NetBeans dla PHP</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>PHP</category>
                                    <content:encoded>&lt;p&gt;Nadchodzące wydanie NetBeans będzie zawierało w sobie pewną małą, ale istotną,
nowość dla wszystkich piszących w PHP i dbających o jakość stylu wytwarzanego 
oprogramowania.&lt;/p&gt;

&lt;h3 id=&quot;codesniffer-szyty-na-miar%C4%99&quot;&gt;CodeSniffer szyty na miarę&lt;/h3&gt;

&lt;p&gt;Jak można przeczytać na &lt;a href=&quot;https://blogs.oracle.com/netbeansphp/entry/php_tools_minor_improvements&quot;&gt;blogu dotyczącym wsparcia dla PHP w NetBeans&lt;/a&gt;, już 
niebawem, w kolejnej wersji oznaczonej numerem 8.2, możliwe będzie podłączenie
własnego pliku konfiguracyjnego dla analizatora stylu i składni jakim jest 
CodeSniffer. Oznacza to że od tego momentu możliwe będzie bardziej wybiórcze 
skonfigurowanie co ma być sprawdzane i raportowane przez NetBeans. Pomoże to 
wszystkim projektom które zmuszone są (np. z powodu &lt;em&gt;&quot;legacy code&quot;&lt;/em&gt;) pominąć
niektóre z &lt;a href=&quot;http://www.php-fig.org/psr/&quot;&gt;reguł proponowanych w PSR&lt;/a&gt;, a także tym projektom w których zdecydowano 
się stosować niestandardowe reguły sprawdzania składni.&lt;/p&gt;

&lt;h3 id=&quot;phpunit-na-%2Acito%2A&quot;&gt;PHPUnit na &lt;em&gt;cito&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Kolejnym usprawnieniem dla PHP wprowadzanym w NB 8.2 ma być pokazywanie wyników
testów napisanych w PHPUnit na bieżąco podczas ich wykonywania, a nie jak to jest
teraz dopiero po ich zakończeniu. Jest to, moim zdaniem, raczej zmiana kosmetyczna,
ale dobre i to.&lt;/p&gt;

&lt;p&gt;Czekamy więc na oficjalne wydanie NB 8.2. Niecierpliwi mogą już dziś testować te
i inne zmiany &lt;a href=&quot;http://bits.netbeans.org/dev/nightly/&quot;&gt;pobierając wersję &lt;em&gt;&quot;nightly&quot;&lt;/em&gt; ze strony producenta&lt;/a&gt;.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-07-20T21:10:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/07/20/male-wielkie-zmiany-w-netbeans-dla-php.html</link>
            <atom:link href="http://lion.net.pl/2016/07/20/male-wielkie-zmiany-w-netbeans-dla-php.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/07/20/male-wielkie-zmiany-w-netbeans-dla-php.html</guid>
        </item>
                <item>
            <title>Przekształcenia morfologiczne, kontekstowe i rozmyte</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>GKIRO</category>
                                    <content:encoded>&lt;p&gt;Post ten jest pierwszym z trzech w cyklu związanym z tematem &lt;strong&gt;badania wpływu
wstępnej filtracji obrazu na wyniki segmentacji wododziałowej&lt;/strong&gt;. Temat ten powinien
zainteresować wszystkie osoby rozpoczynające swoją przygodę z grafiką komputerową
i analizą obrazu.&lt;/p&gt;

&lt;p&gt;W pierwszej części postaram się przybliżyć pojęcia związane z podstawowymi
przekształceniami jakie można wykonać na obrazie. W drugiej części omówiona 
zostanie segmentacja wododziałowa. Kolejny wpis będzie dotyczył narzędzia jakie 
napisałem w celu przeprowadzania badań wpływu wstępnych przekształceń na wyniki 
segmentacji wododziałową. Tematem ostatniego wpisu w tym cyklu będą natomiast 
same wyniki, które udało się uzyskać podczas badania obrazów RTG szczęki człowieka.&lt;/p&gt;

&lt;p&gt;Zacznijmy od teorii.&lt;/p&gt;

&lt;h3 id=&quot;przekszta%C5%82cenia-obrazu&quot;&gt;Przekształcenia obrazu&lt;/h3&gt;

&lt;h4 id=&quot;przekszta%C5%82cenia-punktowe&quot;&gt;Przekształcenia punktowe&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Wyrównanie histogramu&lt;/strong&gt; jest to przykład przekształcenia punktowego obrazu w wyniku 
którego otrzymuje się obraz, w którym wszystkie poziomy szarości są równomiernie 
wykorzystane. Wyjściowy obraz charakteryzuje się lepszym kontrastem. Jeśli 
prawdopodobieństwo wystąpienia poziomu szarości wynosi:&lt;/p&gt;

&lt;p&gt;$$ p(r_k)=\frac{n_k}{n} $$&lt;/p&gt;

&lt;p&gt;gdzie: $$r_k$$ -- poziom szarości k, $$n_k$$ -- liczba pikseli w obrazie 
wejściowym, których wartość wynosi $$r_k$$, $$n$$ -- liczba wszystkich pikseli 
w obrazie, to wzór na wyrównanie histogramu przedstawia się następująco:&lt;/p&gt;

&lt;p&gt;$$ s_k = \sum_{0&amp;lt;j&amp;lt;k}p(r_j) = \sum_{0&amp;lt;j&amp;lt;k}\frac{n_j}{n} $$&lt;/p&gt;

&lt;p&gt;gdzie: $$s_k$$ -- poziom szarości w obrazie wyjściowym, $$k = 0,\ldots,L-1$$, 
L -- liczba odcieni szarości w obrazie wejściowym[&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;].&lt;/p&gt;

&lt;h4 id=&quot;przekszta%C5%82cenia-morfologiczne&quot;&gt;Przekształcenia morfologiczne&lt;/h4&gt;

&lt;p&gt;Przekształcenia morfologiczne polegają na wykonywaniu podstawowych przekształceń 
zbiorów, takich jak suma, różnica, dopełnienie i translacja, na elementach zbioru 
jakim jest obraz - na pikselach. W przekształceniach morfologicznych często 
stosuje się element strukturujący - niewielki, specjalnie przygotowany zbiór 
wartości będący argumentem funkcji przekształcenia morfologicznego
[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;].&lt;/p&gt;

&lt;h4 id=&quot;translacja&quot;&gt;Translacja&lt;/h4&gt;

&lt;p&gt;Translacja zbioru $$A$$ przez wektor $$b$$ oznacza że każdy element zbioru $$A$$ 
jest przesunięty w swojej dziedzinie zgodnie ze wzorem
[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ A+b = &amp;#123;(a+h)|a \in A&amp;#125; $$&lt;/p&gt;

&lt;h4 id=&quot;erozja&quot;&gt;Erozja&lt;/h4&gt;

&lt;p&gt;Erozja obrazu $$A$$ elementem strukturującym $$B$$ oznacza iloczyn translacji 
$$A$$ poszczególnymi elementami zbioru $$B$$
[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ E(A,B) = \bigcap_{b \in B}(A-b) $$&lt;/p&gt;

&lt;h4 id=&quot;dylacja&quot;&gt;Dylacja&lt;/h4&gt;

&lt;p&gt;Dylacja obrazu $$A$$ elementem strukturującym $$B$$ oznacza sumę translacji $$A$$
poszczególnymi elementami zbioru $$B$$[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ D(A,B) = \bigcup_{b \in B}(A+b) $$&lt;/p&gt;

&lt;h4 id=&quot;otwarcie&quot;&gt;Otwarcie&lt;/h4&gt;

&lt;p&gt;Otwarcie obrazu $$A$$ elementem strukturującym $$B$$ jest złożeniem erozji oraz 
dylacji[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ O(A,B) = D(E(A,B),B) $$&lt;/p&gt;

&lt;h4 id=&quot;zamkni%C4%99cie&quot;&gt;Zamknięcie&lt;/h4&gt;

&lt;p&gt;Zamknięcie obrazu $$A$$ elementem strukturującym $$B$$ jest złożeniem dylacji 
oraz erozji[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ C(A,B) = E(D(A,B),B) $$&lt;/p&gt;

&lt;h4 id=&quot;white-top-hat&quot;&gt;White Top Hat&lt;/h4&gt;

&lt;p&gt;Transformata White Top Hat oznacza różnicę obrazu wejściowego $$A$$ i jego 
otwarcia elementem strukturującym $$B$$[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ WTH(A,B) = A-O(A,B) $$&lt;/p&gt;

&lt;h4 id=&quot;black-top-hat&quot;&gt;Black Top Hat&lt;/h4&gt;

&lt;p&gt;Transformata Black Top Hat oznacza różnicę zamknięcia obrazu $$A$$ elementem 
strukturującym $$B$$ i obrazu wejściowego $$A$$
[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ BTH(A,B) = C(A,B)-A $$&lt;/p&gt;

&lt;h4 id=&quot;gradient-morfologiczny&quot;&gt;Gradient morfologiczny&lt;/h4&gt;

&lt;p&gt;Gradient morfologiczny oznacza różnicę pomiędzy dylacją obrazu $$A$$ elementem 
strukturującym $$B$$ a erozją tego samego obrazu tym samym elementem 
strukturującym[&lt;a href=&quot;#segm-obr-cyfr&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;]:&lt;/p&gt;

&lt;p&gt;$$ G(A,B) = D(A,B)-E(A,B) $$&lt;/p&gt;

&lt;h3 id=&quot;przekszta%C5%82cenia-kontekstowe&quot;&gt;Przekształcenia kontekstowe&lt;/h3&gt;

&lt;h4 id=&quot;filtr-medianowy&quot;&gt;Filtr medianowy&lt;/h4&gt;

&lt;p&gt;Przekształcenie nazywane filtrem medianowym polega na przypisaniu pikselowi 
znajdującemu się pośrodku okna wartości będącej medianą wartości pikseli 
znajdujących się w danym oknie. Filtry medianowe pozwalają na usunięcie z obrazów 
szumów, zwłaszcza szumów typu &quot;pieprz i sól&quot;, przy czym nie wpływają znacząco na 
kontury obiektów znajdujących się na obrazie. Okna stosowane w filtrach 
medianowych mają kształt kwadratów o środku znajdującym się na współrzędnych 
aktualnie rozpatrywanego piksela[&lt;a href=&quot;#wyklady-gkiro&quot;&gt;1&lt;/a&gt;].&lt;/p&gt;

&lt;h3 id=&quot;przekszta%C5%82cenia-wykorzystuj%C4%85ce-elementy-logiki-rozmytej&quot;&gt;Przekształcenia wykorzystujące elementy logiki rozmytej&lt;/h3&gt;

&lt;h4 id=&quot;zbiory-rozmyte&quot;&gt;Zbiory rozmyte&lt;/h4&gt;

&lt;p&gt;Logika rozmyta jest produktem teorii zbiorów rozmytych. W teorii zbiorów 
rozmytych, w przeciwieństwie do klasycznej teorii zbiorów, przynależność 
elementu do zbioru nie jest opisana przy pomocy zbioru dwóch wartości &amp;#123;0, 1&amp;#125;, 
lecz jako wartość z przedziału [0, 1]. Dzięki temu możliwe jest takie 
przedstawianie podzbiorów wszystkich możliwych wartości rozpatrywanych zbiorów 
na jakie wskazywałaby baza zebranej wiedzy. Wartości z przedziału [0, 1], 
przypisywane poszczególnym elementom zbiorów rozmytych noszą nazwę stopni 
przynależności danego elementu do zbioru[&lt;a href=&quot;#ster-rozm&quot;&gt;3&lt;/a&gt;].&lt;/p&gt;

&lt;h4 id=&quot;zmienne-lingwistyczne&quot;&gt;Zmienne lingwistyczne&lt;/h4&gt;

&lt;p&gt;W teorii zbiorów rozmytych występują zbiory określane poprzez zmienne lingwistyczne:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Przez &lt;em&gt;zmienną lingwistyczną&lt;/em&gt; rozumiemy zmienną, której wartościami są słowa 
  lub zdania w języku naturalnym lub sztucznym. Dla przykładu &lt;em&gt;Wiek&lt;/em&gt; jest zmienną 
  lingwistyczną, jeśli jej wartości są wyrażone słowami, a nie liczbami, to znaczy 
  &lt;em&gt;młody&lt;/em&gt;, &lt;em&gt;niemłody&lt;/em&gt;, &lt;em&gt;bardzo młody&lt;/em&gt;, &lt;em&gt;całkiem młody&lt;/em&gt;, &lt;em&gt;stary&lt;/em&gt;, &lt;em&gt;nie bardzo stary&lt;/em&gt;, 
  &lt;em&gt;nie bardzo młody&lt;/em&gt; itd. zamiast 20, 21, 22, 23, ...[&lt;a href=&quot;#ster-rozm&quot;&gt;3&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/podobienstwo_pikseli_fuzzy.png&quot; 
        alt=&quot;Zbiory rozmyte - podobieństwo pikseli, przykład rysunek poglądowy&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 1: Zbiory rozmyte - podobieństwo pikseli, przykład rysunek poglądowy
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Dzięki zastosowaniu zmiennych lingwistycznych o wiele łatwiejsze stało się takie 
opisywanie badanych wielkości, by utworzone przedziały odzwierciedlały wiedzę 
ekspertów w danej dziedzinie. Zastosowanie zbiorów rozmytych, połączone z 
tworzeniem bazy wiedzy eksperckiej, pozwoliło na o wiele łatwiejsze, a dzięki 
temu szybsze, rozwiązanie wielu problemów z dziedziny automatyki i elektroniki. 
Algorytmy wykorzystujące zbiory rozmyte wykorzystywane są w sterowaniu procesami 
wytwórczymi, sterowaniu powszechnie używanymi urządzeniami elektronicznymi oraz 
w innych dziedzinach. Algorytmy te zostały wykorzystane w wielu dziedzinach 
informatyki, w tym także w grafice komputerowej. W przypadku obrazu, 
rozpatrywanym zagadnieniem może być np. podobieństwo pikseli, a utworzonymi 
zmiennymi lingwistycznymi oceny jakie można temu podobieństwu przypisać, np. 
&lt;em&gt;bardzo małe&lt;/em&gt;, &lt;em&gt;małe&lt;/em&gt;, &lt;em&gt;średnie&lt;/em&gt;, &lt;em&gt;duże&lt;/em&gt;, &lt;em&gt;bardzo duże&lt;/em&gt;. Przykład takich zbiorów 
rozmytych, przedstawiony w formie wykresy pokazano na rysunku 1. Widać na nim, 
że zbiory nie są ostre, istnieją takie wartości różnicy intensywności pikseli, 
dla których przynależność do danego zbioru zawiera się w przedziale [0, 1]. Co 
więcej istnieją takie wartości różnicy intensywności pikseli, dla których 
wartość ta zawiera się w dwóch (w tym przypadku), ogólnie w więcej niż jednym 
zbiorze. Odzwierciedla to sytuację, w której ekspert dziedziny nie może 
jednoznacznie wskazać do jakiego zbiory przyporządkować zadany element
[&lt;a href=&quot;#ster-rozm&quot;&gt;3&lt;/a&gt;].&lt;/p&gt;

&lt;h4 id=&quot;regu%C5%82y-decyzyjne&quot;&gt;Reguły decyzyjne&lt;/h4&gt;

&lt;p&gt;Do opisu związków pomiędzy zbiorami wprowadzono wyrażenia warunkowe w postaci:&lt;/p&gt;

&lt;p&gt;$$ jeżeli \langle\ poprzednik&amp;#95;reguly\ \rangle\ to \langle\ nastepnik&amp;#95;reguly\ \rangle $$&lt;/p&gt;

&lt;p&gt;Każde takie wyrażenie nazywane jest regułą decyzyjną, lub w skrócie regułą[&lt;a href=&quot;#ster-rozm&quot;&gt;3&lt;/a&gt;].&lt;/p&gt;

&lt;h4 id=&quot;filtr-redukuj%C4%85cy-szum-wykorzystuj%C4%85cy-elementy-logiki-rozmytej&quot;&gt;Filtr redukujący szum wykorzystujący elementy logiki rozmytej&lt;/h4&gt;

&lt;p&gt;W artykule [&lt;a href=&quot;#fuzzy-noise-reduction&quot;&gt;4&lt;/a&gt;] zaproponowano algorytm służący do 
redukcji szumu na obrazach, wykorzystujący technikę rozmytą. Działanie algorytmu 
dzieli się na dwie części. Podczas pierwszej z nich, dla każdego piksela obrazu 
określane jest czy jest on pikselem będącym szumem i w jakim stopniu można to 
określić, etap ten nazwano &lt;em&gt;Fuzzy Noise Estimation&lt;/em&gt;. Określenie czy piksel 
zawiera szum następuje po obliczeniu dwóch parametrów rozmytych. Pierwszy z nich 
to różnica w intensywności koloru pomiędzy danym pikselem a pikselami w jego 
8-sąsiedztwie, dalej oznaczana jako &lt;em&gt;deg&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;$$ dif = min|f(x, y)-f(x&#039;, y&#039;)| $$&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/fuzzy/fuzzy_dif_chart.png&quot; 
        alt=&quot;Wykres stopnia przynależności parametru dif&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 2: Wykres stopnia przynależności parametru &lt;em&gt;dif&lt;/em&gt;. 
        Reprodukcja z &lt;a href=&quot;#fuzzy-noise-reduction&quot;&gt;4&lt;/a&gt;.
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Pierwszy parametr może przyjmować następujące wartości lingwistyczne: &lt;em&gt;Low&lt;/em&gt;, 
&lt;em&gt;Medium&lt;/em&gt;, &lt;em&gt;High&lt;/em&gt;. Wykres stopni przynależności pokazano na rysunku 2.&lt;/p&gt;

&lt;p&gt;Drugi parametr to liczba pikseli podobnych do danego piksela w jego 8-sąsiedztwie, 
dalej oznaczany jako &lt;em&gt;num&lt;/em&gt;. Podobieństwo określa się na podstawie różnicy 
intensywności koloru i progu, poniżej którego ta różnica oznacza podobieństwo, 
a powyżej którego niepodobieństwo dwóch pikseli:&lt;/p&gt;

&lt;p&gt;$$ num = &amp;#123; (x&#039;, y&#039;)|(x&#039;, y&#039;) \in N_8 (x, y) \&amp;amp; |f(x, y) - f (x&#039;, y&#039;)| &amp;lt; treshold &amp;#125; $$&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/fuzzy/fuzzy_num_chart.png&quot; 
        alt=&quot;Wykres stopnia przynależności parametru num&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 3: Wykres stopnia przynależności parametru &lt;em&gt;num&lt;/em&gt;. 
        Reprodukcja z &lt;a href=&quot;#fuzzy-noise-reduction&quot;&gt;4&lt;/a&gt;.
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Drugi parametr może przyjmować następujące wartości lingwistyczne: &lt;em&gt;None&lt;/em&gt;, &lt;em&gt;Few&lt;/em&gt;, 
&lt;em&gt;Many&lt;/em&gt;. Wykres stopni przynależności pokazano na rysunku 3.&lt;/p&gt;

&lt;p&gt;Na podstawie przedstawionych wcześniej parametrów przygotowano następujące reguły 
decyzyjne, wyznaczające stopień w jakim dany piksel jest uznawany za piksel 
zaszumiony, danej oznaczany jako &lt;em&gt;deg&lt;/em&gt;. Parametr ten może przyjmować wartości 
lingwistyczne takie jak &lt;em&gt;Small&lt;/em&gt;, &lt;em&gt;Moderate&lt;/em&gt;, &lt;em&gt;Big&lt;/em&gt;, &lt;em&gt;Very Big&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest Low) &lt;strong&gt;i&lt;/strong&gt; (num jest None) &lt;strong&gt;to&lt;/strong&gt; (deg jest Moderate)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest Low) &lt;strong&gt;i&lt;/strong&gt; (num jest Few) &lt;strong&gt;to&lt;/strong&gt; (deg jest Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest Low) &lt;strong&gt;i&lt;/strong&gt; (num jest Many) &lt;strong&gt;to&lt;/strong&gt; (deg jest Very Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest Medium) &lt;strong&gt;i&lt;/strong&gt; (num jest None) &lt;strong&gt;to&lt;/strong&gt; (deg jest Small)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest Medium) &lt;strong&gt;i&lt;/strong&gt; (num jest Few) &lt;strong&gt;to&lt;/strong&gt; (deg jest Moderate)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest Medium) &lt;strong&gt;i&lt;/strong&gt; (num jest Many) &lt;strong&gt;to&lt;/strong&gt; (deg jest Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest High) &lt;strong&gt;i&lt;/strong&gt; (num jest None) &lt;strong&gt;to&lt;/strong&gt; (deg jest Small)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest High) &lt;strong&gt;i&lt;/strong&gt; (num jest Few) &lt;strong&gt;to&lt;/strong&gt; (deg jest Moderate)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (dif jest High) &lt;strong&gt;i&lt;/strong&gt; (num jest Many) &lt;strong&gt;to&lt;/strong&gt; (deg jest Moderate)&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/fuzzy/fuzzy_deg_chart.png&quot; 
        alt=&quot;Wykres stopnia przynależności parametru deg&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 4: Wykres stopnia przynależności parametru &lt;em&gt;deg&lt;/em&gt;. 
        Reprodukcja z &lt;a href=&quot;#fuzzy-noise-reduction&quot;&gt;4&lt;/a&gt;.
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Wykres stopni przynależności pokazano na rysunku 4.&lt;/p&gt;

&lt;p&gt;Parametr &lt;em&gt;deg&lt;/em&gt; jest wyjściem algorytmu &lt;em&gt;Fuzzy Noise Estimation&lt;/em&gt;, a jednocześnie 
jednym z argumentów wejściowych dla algorytmu &lt;em&gt;Fuzzy Smoothing&lt;/em&gt;. W drugim 
algorytmie, aby wyliczyć wagi dla wszystkich pikseli znajdujących się w 
8-sąsiedztwie obliczany jest parametr &lt;em&gt;diff&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;$$ diff = |f(x,y) - f(x-k, y-l)| $$&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/fuzzy/fuzzy_diff_chart.png&quot; 
        alt=&quot;Wykres stopnia przynależności parametru diff&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 5: Wykres stopnia przynależności parametru &lt;em&gt;diff&lt;/em&gt;. 
        Reprodukcja z &lt;a href=&quot;#fuzzy-noise-reduction&quot;&gt;4&lt;/a&gt;.
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Wykres stopni przynależności pokazano na rysunku 5. Jeśli wynik działania jest 
&lt;em&gt;duży&lt;/em&gt; to &lt;em&gt;mała&lt;/em&gt; waga powinna zostać przypisana do danego piksela, by zredukować 
jego udział w procesie uśredniania.&lt;/p&gt;

&lt;p&gt;Na podstawie otrzymanych wartości rozmytych &lt;em&gt;diff&lt;/em&gt; oraz wyjścia poprzedniego 
algorytmu &lt;em&gt;deg&lt;/em&gt; utworzono następujące reguły decyzyjne wyznaczające parametr 
&lt;em&gt;weight&lt;/em&gt; będący zbiorem rozmytym w którym znajduje się szukana wartość wagi dla 
danego piksela:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Small) &lt;strong&gt;i&lt;/strong&gt; (deg jest Low) &lt;strong&gt;to&lt;/strong&gt; (weight jest Small)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Small) &lt;strong&gt;i&lt;/strong&gt; (deg jest Moderate) &lt;strong&gt;to&lt;/strong&gt; (weight jest Moderate)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Small) &lt;strong&gt;i&lt;/strong&gt; (deg jest Big) &lt;strong&gt;to&lt;/strong&gt; (weight jest Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Small) &lt;strong&gt;i&lt;/strong&gt; (deg jest Very Big) &lt;strong&gt;to&lt;/strong&gt; (weight jest Very Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Medium) &lt;strong&gt;i&lt;/strong&gt; (deg jest Low) &lt;strong&gt;to&lt;/strong&gt; (weight jest Small)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Medium) &lt;strong&gt;i&lt;/strong&gt; (deg jest Moderate) &lt;strong&gt;to&lt;/strong&gt; (weight jest Moderate)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Medium) &lt;strong&gt;i&lt;/strong&gt; (deg jest Big) &lt;strong&gt;to&lt;/strong&gt; (weight jest Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Medium) &lt;strong&gt;i&lt;/strong&gt; (deg jest Very Big) &lt;strong&gt;to&lt;/strong&gt; (weight jest Very Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Large) &lt;strong&gt;i&lt;/strong&gt; (deg jest Low) &lt;strong&gt;to&lt;/strong&gt; (weight jest Small)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Large) &lt;strong&gt;i&lt;/strong&gt; (deg jest Moderate) &lt;strong&gt;to&lt;/strong&gt; (weight jest Moderate)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Large) &lt;strong&gt;i&lt;/strong&gt; (deg jest Big) &lt;strong&gt;to&lt;/strong&gt; (weight jest Big)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jeżeli&lt;/strong&gt; (diff jest Large) &lt;strong&gt;i&lt;/strong&gt; (deg jest Very Big) &lt;strong&gt;to&lt;/strong&gt; (weight jest Very Big)&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/img/gkiro/fuzzy/fuzzy_weight_chart.png&quot; 
        alt=&quot;Wykres stopnia przynależności parametru weight&quot;&gt;
    &lt;figcaption&gt;
        Rysunek 6: Wykres stopnia przynależności parametru &lt;em&gt;weight&lt;/em&gt;. 
        Reprodukcja z &lt;a href=&quot;#fuzzy-noise-reduction&quot;&gt;4&lt;/a&gt;.
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Wykres stopni przynależności pokazano na rysunku 6. Na podstawie otrzymanych w 
algorytmie &lt;em&gt;Fuzzy Smoothing&lt;/em&gt; wartości dobiera się wagi dla pikseli znajdujących 
się w oknie 3x3 i oblicza nową wartość dla dla piksela centralnego.&lt;/p&gt;

&lt;h2 id=&quot;literatura&quot;&gt;Literatura&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a name=&quot;wyklady-gkiro&quot;&gt;
    &lt;strong&gt;A. Świtoński. &lt;em&gt;Wykłady z przedmiotu Grafika Komputerowa i 
    Rozpoznawanie Obrazów&lt;/em&gt;.&lt;/strong&gt; Politechnika Śląska, 2013
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&quot;segm-obr-cyfr&quot;&gt;&lt;strong&gt;M. Nieniewski. &lt;em&gt;Segmentacja obrazów cyfrowych. Metody segmentacji wododziałowej&lt;/em&gt;.&lt;/strong&gt; Akademicka Oficyna Wydawnicza EXIT, 2005&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&quot;ster-rozm&quot;&gt;&lt;strong&gt;D. Driankov, H. Hellendoorm, M. Reinfrank. &lt;em&gt;Wprowadzenie do sterowania rozmytego&lt;/em&gt;.&lt;/strong&gt; Wydawnictwa Naukowo-Techniczne, 1993&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&quot;fuzzy-noise-reduction&quot;&gt;&lt;strong&gt;H. V. Nejad, H. R. Pourreza, H. Ebrahimi. &lt;em&gt;A Novel Fuzzy Technique for Image Noise Reduction&lt;/em&gt;.&lt;/strong&gt; World Academy Of Science, Engineering and Technology, 2008&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Treść tego wpisu zawiera fragmenty mojej pracy dyplomowej &lt;strong&gt;&quot;Badanie wpływu 
wstępnej filtracji na proces segmentacji w analizie patologicznych zmian w 
obrębie zębów widocznych na zdjęciach RTG&quot;&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Zobacz także:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/07/24/emgucvdemo-aplikacja-testujaca-wplyw-wybranych-filtrow-na-wyniki-segmentacji-wododzialowej.html&quot;&gt;EmguCVDemo - aplikacja testująca wpływ wybranych filtrów na wyniki segmentacji wododziałowej&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/08/06/wplyw-wstepnej-filtracji-na-segmentacje-wododzialowa.html&quot;&gt;Wpływ wstępnej filtracji na segmentację wododziałową&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
            <pubDate>2016-07-03T09:30:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/07/03/przeksztalcenia-morfologiczne-kontekstowe-i-rozmyte.html</link>
            <atom:link href="http://lion.net.pl/2016/07/03/przeksztalcenia-morfologiczne-kontekstowe-i-rozmyte.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/07/03/przeksztalcenia-morfologiczne-kontekstowe-i-rozmyte.html</guid>
        </item>
                <item>
            <title>Dałem się poznać</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>DDF</category>
                        <category>BLOG</category>
                                    <content:encoded>&lt;p&gt;Przez ostatnie 3 miesiące mogłeś śledzić jak sobie radzę w konkursie &lt;em&gt;&quot;Daj się 
poznać 2016&quot;&lt;/em&gt;. Mam nadzieję, że dałem się poznać z tej lepszej strony. Teraz gdy 
już po wszystkim, gdy emocje opadają a projekty są skończone, czas na małą 
refleksję.&lt;/p&gt;

&lt;h3 id=&quot;wyniki-konkursu&quot;&gt;Wyniki konkursu&lt;/h3&gt;

&lt;p&gt;Konkurs &lt;a href=&quot;http://devstyle.pl/2016/06/01/daj-sie-poznac-2016-wielki-final&quot;&gt;został zakończony&lt;/a&gt;, została ogłoszona &lt;a href=&quot;http://devstyle.pl/daj-sie-poznac/daj-sie-poznac-finalisci-2016&quot;&gt;lista bohaterów&lt;/a&gt;. Tym 
wszystkim osobom udało się dotrwać do końca i spełnić warunki konkursu. Miło mi
że &lt;strong&gt;jedną z tych 70 osób jestem ja&lt;/strong&gt;. Gdy 3 miesiące temu startowałem nie myślałem
że zgłosi się prawie 300 osób, liczyłem że będzie to góra 50 programistycznych
geeków. A tu taka niespodzianka. Okazuje się że jest nas sporo, że ludzie interesują
się samorozwojem i nadspodziewanie optymistycznie podchodzą do takich inicjatyw
jak DPS2016. W tym zawodzie ciągły rozwój to podstawa! Oby tak dalej! Życzę nam
wszystkim dalszej wytrwałości w dążeniu do perfekcji w dziedzinie wytwarzania
oprogramowania!&lt;/p&gt;

&lt;h4 id=&quot;fina%C5%82&quot;&gt;Finał&lt;/h4&gt;

&lt;p&gt;Z grupy bohaterów &lt;a href=&quot;http://devstyle.pl/2016/06/08/daj-sie-poznac-2016-glosowanie-i-gala/&quot;&gt;została wybrana w wewnętrznym głosowaniu szczęśliwa 16-tka&lt;/a&gt;, 
której projekty i blog najbardziej spodobał się konkurencji. Niestety tam już się
nie załapałem... Gratuluję szczęśliwcom.&lt;/p&gt;

&lt;p&gt;Wśród finalistów znalazł się jeden z blogów i powiązana aplikacja, na który oddałem 
swój głos. Jest to &lt;strong&gt;&lt;a href=&quot;http://programistka.net&quot;&gt;aplikacja mobilna służąca do planowania zakupów&lt;/a&gt;&lt;/strong&gt;, napisana 
w Java. Tą aplikację zauważyłem dopiero po zakończeniu konkursu, jednak po 
przejrzeniu wszystkich innych, zarówno tych które śledziłem jak i tych na które nie
starczyło mi czasu, wydaje mi się że &lt;strong&gt;najbardziej zasługuje na wyróżnienie&lt;/strong&gt;. 
Wygląda całkiem fajnie na zaprezentowanych screenach, może kiedyś przetestuję ją 
także na telefonie. Autorce udało się zrobić całkiem sporo w tak krótkim czasie.&lt;/p&gt;

&lt;p&gt;Ciekawymi projektami, które jednak nie przeszły dalej były są także:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://incodable.blogspot.com&quot;&gt;aplikacja służąca do planowania tras wycieczek&lt;/a&gt;, napisana w Ionic Framework.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jsdn.pl&quot;&gt;gra platformowa napisana w JS&lt;/a&gt;, a także kilka innych gierek które można 
znaleźć na blogu tego uczestnika.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ogólnie można zauważyć że na liście finalistów królują projekty i blogi powiązane
z technologiami &lt;em&gt;.NET&lt;/em&gt; (11/16), jest też trochę o Java (2/16) oraz JavaScript i C.
Takie nierównomierne rozłożenie technologii było już widać na poprzednich etapach
konkursu, ale jest to pewnie związane z tym że sam konkurs wypłynął z środowiska
.NETowców, a głównym sponsorem jest sami wiecie kto ;). &lt;a href=&quot;http://macieklesiczka.github.io/&quot;&gt;Ciekawe statystyki 
konkursu&lt;/a&gt; można znaleźć na stronie jednego z finalistów który pisał aplikację 
do zbierania danych o konkursie.&lt;/p&gt;

&lt;p&gt;Pozostaje teraz czekać na &lt;a href=&quot;http://ankieta.dajsiepoznac.pl/&quot;&gt;wyniki ankiety kolejnej ankiety&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;m%C3%B3j-blog&quot;&gt;Mój blog&lt;/h3&gt;

&lt;p&gt;Konkurs miał duży pozytywny wpływ na ten blog. &lt;strong&gt;Udało mi się przez 3 miesiące 
napisać 28 postów&lt;/strong&gt; z czego &lt;a href=&quot;blog/tags/#DSP2016&quot;&gt;27 było postami konkursowymi&lt;/a&gt;. &lt;strong&gt;Napisałem
w sumie aż 13525 słów&lt;/strong&gt; co daje średnio 500 słów na post. Dawno się tak nie rozpisywałem.
Ogólnie jestem bardzo zadowolony z merytorycznej wartości każdego z opublikowanych
postów. Ich przygotowanie kosztowało mnie trochę czasu, ale jest to dobrze
spożytkowany czas - raz napisany i opublikowany post zostanie tu na zawsze i 
będzie przyciągał czytelników.&lt;/p&gt;

&lt;p&gt;Blog przeszedł w tym czasie także spory lifting, nadal charakteryzuje go 
minimalistyczna forma, nadal jest &lt;a href=&quot;/2014/06/19/ready-steady-blog.html&quot;&gt;hostowany na GitHub Pages a jego silnikiem 
jest Jekyll&lt;/a&gt;. Udało mi się jednak poświęcić trochę czasu aby jego czytanie
było łatwiejsze wprowadzając trochę więcej semantyki i RWD w kod bloga.&lt;/p&gt;

&lt;h4 id=&quot;kana%C5%82-rss&quot;&gt;Kanał RSS&lt;/h4&gt;

&lt;p&gt;Jednym z warunków uczestnictwa w DSP2016 było udostępnienie kanału RSS czytelnikom.
Sama idea kanałów RSS tak bardzo mi się spodobała, że od razu w rozszerzyłem swój 
czytnik poczty o czytnik kanałów z wiadomościami z blogów. Jeśli jeszcze nie masz 
kanału RSS na swoim blogu załóż go jak najszybciej - super sprawa. Nie trzeba
zapisywać się żadną listę mailingową by być informowanym na bieżąco.&lt;/p&gt;

&lt;p&gt;Z drugiej strony lista mailingowa daje dużo większe możliwości promocji, jednak
na obecnym etapie byłaby przerostem formy nad treścią.&lt;/p&gt;

&lt;p&gt;Jeśli jeszcze nie zapisałeś się na &lt;a href=&quot;blog/feed.xml&quot;&gt;mój kanał RSS możesz to zrobić klikając w ten
link&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;seo&quot;&gt;SEO&lt;/h4&gt;

&lt;p&gt;Popracowałem także trochę nad optymalizacją strony, tak aby roboty wielkiego brata
czuły się na niej jak w domu, ale jest jeszcze sporo do zrobienia. Nie chciałem
specjalnie spamować gdzie się tylko da, więc jeśli trafiłeś tu z wyszukiwarki to
jest to raczej &lt;strong&gt;zasługa pasywnego SEO&lt;/strong&gt; niż agresywnej autopromocji.&lt;/p&gt;

&lt;p&gt;Nie zdecydowałem się na śledzenie użytkowników, bo w sumie nie jest mi to do niczego
potrzebne, a sam blokuje takie wynalazki jak tylko się da w mojej przeglądarce
(AdBlock, NoScript). Mimo to mogłem w narzędziach dla webmasterów od wielkiego 
brata (zwanych obecnie konsolą), &lt;strong&gt;zauważyć pewien wzrost ruchu na tej stronie&lt;/strong&gt;.
Nie było by go gdyby nie ten konkurs i wyprodukowana przeze mnie treść na blogu.&lt;/p&gt;

&lt;h3 id=&quot;ja&quot;&gt;Ja&lt;/h3&gt;

&lt;p&gt;Konkurs DSP2016 nauczył mnie bardzo wiele o sobie samym. Cieszę się że udało mi
się sprostać warunkom konkursu. Wymagało to ode mnie &lt;strong&gt;dużej konsekwencji w działaniu,
samozaparcia, planowania z wyprzedzeniem&lt;/strong&gt;. Sporo także przy okazji nauczyłem się
o samym JS. Wybranie zestawu technologii o którym nie ma się zielonego pojęcia
okazało się strzałem w dziesiątkę! &lt;strong&gt;Jestem zadowolony&lt;/strong&gt; z &lt;a href=&quot;/2016/05/30/raport-3-z-prac-nad-ddf.html&quot;&gt;rezultatu jaki udało mi
się ostatecznie osiągnąć&lt;/a&gt;. Aplikacja DDF nie powstałaby zapewne gdyby nie ten 
konkurs. Mam nadzieję że &lt;strong&gt;w przyszłości ta &lt;a href=&quot;/2016/03/01/dam-sie-poznac.html&quot;&gt;aplikacja obliczająca dawki leków na
urządzenia mobilne&lt;/a&gt; przyda się komuś w codziennym życiu lub w pracy&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;moje-wsparcie&quot;&gt;Moje wsparcie&lt;/h4&gt;

&lt;p&gt;W tym miejscu chciałbym podziękować wszystkim tym którzy wspierali mnie przez te 
ostatnie 3 miesiące. &lt;strong&gt;W szczególności mojej drugiej połówce, która od samego 
początku wspierała mnie podczas trwania konkursu&lt;/strong&gt;. Bez takiego wsparcia pewnie 
nie dotrwałbym do końca, a tak, wiedząc że pierwszym i najsurowszym recenzentem
będzie najbliższa osoba, która bez chwili zawahania wypunktuje każdy błąd i każdą
fuszerkę, udało mi się dostarczyć Wam kilka całkiem dobrej jakości, merytorycznych 
postów na temat JS, QA  i inżynierii programowania.&lt;/p&gt;

&lt;h4 id=&quot;leo%2C-what%27s-next%3F&quot;&gt;Leo, what&#039;s next?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Zamierzam dalej rozwijać DDF&lt;/strong&gt;. Możecie się spodziewać także kolejnych artykułów
dotyczących JS bo spodobał mi się ten cały frontend, a zwłaszcza możliwość robienia
w JS mobilnych aplikacji hybrydowych. &lt;strong&gt;Mam w planach także serię artykułów o PHP&lt;/strong&gt;, 
czyli o mojej preferowanej technologii. Nie obędzie się bez inżynierii oprogramowania
i technik zapewnienia jakości oprogramowania. Tak więc bądźcie czujni, wpadajcie 
na bloga, &lt;a href=&quot;blog/feed.xml&quot;&gt;zapisujcie się na kanał RSS&lt;/a&gt;!&lt;/p&gt;
</content:encoded>
            <pubDate>2016-06-12T20:20:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/06/12/dalem-sie-poznac.html</link>
            <atom:link href="http://lion.net.pl/2016/06/12/dalem-sie-poznac.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/06/12/dalem-sie-poznac.html</guid>
        </item>
                <item>
            <title>Raport #3 z prac nad DDF</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>JS</category>
                        <category>DDF</category>
                        <category>OOP</category>
                        <category>QA</category>
                                    <content:encoded>&lt;p&gt;To już koniec. Ale coś jest. Jest skończona aplikacja na konkurs DSP2016! Zachęcam
do zapoznania się z trzecim i ostatnim raportem z prac nad DDF wykonanym podczas
trwania DSP2016 (mam zamiar dalej rozwijać aplikację, ale już poza konkursem).&lt;/p&gt;

&lt;h3 id=&quot;post%C4%99py-w-ddf&quot;&gt;Postępy w DDF&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;img/DSP2016/icon.png&quot; alt=&quot;Ikona DDF&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Z powodów opisanych &lt;a href=&quot;/2016/05/28/szewc-ze-starym-smartfonem-chodzi.html&quot;&gt;przeze mnie ostatnio&lt;/a&gt;, postanowiłem przesunąć funkcjonalność
polegającą na możliwości wskazywania plików z lekami i ich dawkowaniem do &lt;a href=&quot;/2016/04/29/podroz-na-wschod-roadmap-z-moscow.html&quot;&gt;sekcji
&quot;COULD&quot; analizy wymagań&lt;/a&gt;. Zostały za to spełnione inne wymagania, czyli 
&lt;a href=&quot;/2016/04/26/i18n-z-angularjs-gettext.html&quot;&gt;wdrożenie I18N&lt;/a&gt;, &lt;a href=&quot;/2016/05/26/ikony-i-splash-screen-aplikacji-w-ionic-framework.html&quot;&gt;dodanie ikony i splash screena&lt;/a&gt; (widoczne obok).
Została wydana &lt;a href=&quot;https://github.com/maciejlew/drug-dose-framework/releases/tag/v0.3.0&quot;&gt;wersja 0.3 aplikacji DDF, do pobrania z repozytorium&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;model&quot;&gt;Model&lt;/h4&gt;

&lt;p&gt;Model aplikacji nie zmienił się od czasu &lt;a href=&quot;/2016/04/14/raport-2-z-prac-nad-ddf.html&quot;&gt;poprzedniego raportu&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;kontroler&quot;&gt;Kontroler&lt;/h4&gt;

&lt;p&gt;Jeśli chodzi o kontrolery to tutaj zaszły pewne zmiany. Dodałem obsługę &lt;a href=&quot;/2016/04/19/powiadomienia-w-ionic-framework.html&quot;&gt;powiadomień 
z Ionic Framework&lt;/a&gt;. Wprowadziłem &lt;a href=&quot;/2016/04/26/i18n-z-angularjs-gettext.html&quot;&gt;wsparcie dla I18N&lt;/a&gt; - udało mi się to 
zrobić tak, że &lt;a href=&quot;/2016/05/10/zmiana-jezyka-on-the-fly-w-ionic-i-angular-gettext.html&quot;&gt;zmiana języka odbywa się bez konieczności przeładowania aplikacji 
na telefonie&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;widoki&quot;&gt;Widoki&lt;/h4&gt;

&lt;p&gt;Został zmieniony sposób w jaki przechodzi się do szczegółów leku oraz do kalkulatora
dawki leku. Dodano zostało wysuwane boczne menu. Z tego menu można przejść do 
widoku ustawień językowych. Poniżej przedstawiam galerię prezentującą poszczególne
widoki:&lt;/p&gt;

&lt;div class=&quot;gallery&quot;&gt;

    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-drug-list-polish.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-drug-list-polish.png&quot; alt=&quot;lista leków&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-drug-details.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-drug-details.png&quot; alt=&quot;szczegóły leku&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-dose-calculator.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-dose-calculator.png&quot; alt=&quot;kalkulator dawki leku&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-dose-result.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-dose-result.png&quot; alt=&quot;wynik obliczenia dawki leku&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-dose-exception.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-dose-exception.png&quot; alt=&quot;komunikat o błędzie podczas obliczania dawki leku&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-language-settings-1.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-language-settings-1.png&quot; alt=&quot;boczne menu prowadzące do widoku zmiany języka aplikacji&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-language-settings-2.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-language-settings-2.png&quot; alt=&quot;formularz zmiany języka aplikacji&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;galleryItem&quot;&gt;
        &lt;div class=&quot;stack twisted&quot;&gt;
            &lt;a href=&quot;{{site.url}}/assets/img/DSP2016/ddf-drug-list-english.png&quot;&gt;
                &lt;img src=&quot;{{site.url}}/assets/img/DSP2016/ddf-drug-list-english.png&quot; alt=&quot;lista leków po angielsku&quot;/&gt;
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h4 id=&quot;testy&quot;&gt;Testy&lt;/h4&gt;

&lt;p&gt;Włączyłem w projekcie &lt;a href=&quot;/2016/05/18/code-coverage-w-karma.html&quot;&gt;raporty pokrycia kodu testami jednostkowymi uruchamianymi
przez Karma&lt;/a&gt;. Pomimo rozwoju aplikacji udało się utrzymać pokrycie na wysokim
poziomie, oscylującym wokół 80%, model przetestowany jest w 100%!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/DSP2016/ddf-code-coverage-1.png&quot; alt=&quot;DDF Karma code coverage report #1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;stan-aplikacji&quot;&gt;Stan aplikacji&lt;/h4&gt;

&lt;p&gt;Ostatnie 3 miesiące były dla mnie bardzo pracowite. Poza codziennymi obowiązkami
zgłosiłem się do DSP2016. Warunki konkursu były bardzo dobrze wyważone - pozwalały
wystartować w nim osobom pracującym, które na rozbudowę aplikacji i blogowanie
mogły poświęcić ograniczoną ilość czasu. Myślę że udało mi się wykorzystać ten 
czas w optymalny sposób. Aplikacja konkursowa działa, może być już wykorzystywana
w zakresie dla którego została wymyślona, czyli do budowy aplikacji obliczających dawki
leków na urządzeniach mobilnych. Użytkownikowi został dostarczony działający
szkielet, do którego wystarczy że wgra &lt;a href=&quot;/2016/03/12/format-opisu-lekow-w-ddf.html&quot;&gt;zestaw interesujących do leków zgodny ze
wspieranym formatem&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;co-dalej-z-ddf%3F&quot;&gt;Co dalej z DDF?&lt;/h4&gt;

&lt;p&gt;Aplikacja będzie dalej rozwijana. W moim wolnym czasie
postaram się dodać kolejne funkcjonalności. Czekam także na opinie użytkowników
i pomysły na dalszy rozwój DDF!&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-30T21:30:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/30/raport-3-z-prac-nad-ddf.html</link>
            <atom:link href="http://lion.net.pl/2016/05/30/raport-3-z-prac-nad-ddf.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/30/raport-3-z-prac-nad-ddf.html</guid>
        </item>
                <item>
            <title>Szewc ze starym smartfonem chodzi</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>JS</category>
                        <category>DDF</category>
                                    <content:encoded>&lt;p&gt;Zawsze uważałem, że telefon powinien służyć do tego do czego został stworzony, 
czyli do dzwonienia, a przynajmniej odbierania połączeń. No może jeszcze do 
wysyłania SMS... Chociaż przeglądanie e-maila też się przydaje... No i może 
jeszcze budzik... I rozbudowana lista kontaktów... I apka do sprawdzania 
autobusów... No dobra wystarczy! W każdym razie, po wejściu na rynek smartfonów
długo się im opierałem, w końcu kupiłem sobie jeden z podanych wyżej powodów.&lt;/p&gt;

&lt;p&gt;Czas mijał, większość ludzi, zwłaszcza tych na abonamencie, rzuciła się w wir 
corocznego zmieniania modeli swoich telefonów (w liczbie mnogiej bo czasami 
jeden to za mało...). Mnie to nie ruszało, zgodnie z zasadą &lt;em&gt;&quot;działa - nie 
ruszaj!&quot;&lt;/em&gt;. Nadszedł jednak taki czas że ten brak pogoni za postępem odbił się 
na moich planach...&lt;/p&gt;

&lt;h3 id=&quot;programowanie-na-urz%C4%85dzenia-mobilne&quot;&gt;Programowanie na urządzenia mobilne&lt;/h3&gt;

&lt;p&gt;Programowanie na urządzenia mobilne jest stosunkowo młodą gałęzią całego biznesu
kręcącego się wokół dostarczania ludzkości nowych rozwiązań informatycznych.
Cały czas się to rozwija - &lt;strong&gt;nowy sprzęt, nowe technologie, nowe frameworki&lt;/strong&gt; - 
trudno za tym wszystkim nadążyć.&lt;/p&gt;

&lt;h4 id=&quot;programowanie-hybrydowe&quot;&gt;Programowanie hybrydowe&lt;/h4&gt;

&lt;p&gt;Na szczęście, &lt;strong&gt;ze zmianami w sprzęcie i jego różnorodnością
można sobie już dziś poradzić przy pomocy frameworków do tworzenia aplikacji 
hybrydowych&lt;/strong&gt;, np. Ionic Framework. Pisanie kodu który działa podobnie, a w każdym 
razie w miarę przewidywalnie, na dużej gamie sprzętu powoduje że takie rozwiązanie
jak Ionic zyskuje ostatnio na popularności. Nie potrzebujemy już znać kilku języków 
programowania, instalować kilku emulatorów lub kupować kilku urządzeń różnych
producentów, by zbudować aplikację z powodzeniem uruchamianą przez szerokie
spektrum użytkowników. Możliwe jest nawet uruchomienie takich aplikacji na 
urządzeniach już dawno zapomnianych nawet przez ich producentów, którzy przestali
im już dostarczać aktualizacje OS. Na przykład &lt;a href=&quot;/2016/04/16/apache-cordova-ionic-framework-i-starsze-wersje-androida.html&quot;&gt;Apache Cordova udało mi się
zmusić do współpracy z archaicznym dziś Androidem 2.3&lt;/a&gt;, choć dokumentacja mówi 
że do działania potrzebna jest dużo nowsza wersja Androida!&lt;/p&gt;

&lt;h5 id=&quot;programowanie-hybrydowe-bez-sprz%C4%99tu&quot;&gt;Programowanie hybrydowe bez sprzętu&lt;/h5&gt;

&lt;p&gt;Podczas programowania aplikacji we frameworku takim jak Ionic wcale nie potrzebujemy
instalować emulatora ani posiadać smartfona. Podstawową funkcjonalność można
bardzo łatwo przetestować w przeglądarce. Oczywiście Ionic wspiera uruchamianie
aplikacji na emulatorze a także wysyłanie jej do podłączonego urządzenia. 
Jednak testowanie w przeglądarce to najszybsze i najwygodniejsze rozwiązanie.
We wbudowanej w przeglądarce konsoli można szybko debugować podstawowe problemy.&lt;/p&gt;

&lt;h5 id=&quot;przegl%C4%85darka-to-nie-wszystko&quot;&gt;Przeglądarka to nie wszystko&lt;/h5&gt;

&lt;p&gt;Niektóre funkcjonalności nie zadziałają nam w przeglądarce. Trudno na przykład
skorzystać z systemu plików, wibracji, powiadomień, listy kontaktów itp. To jednak
trzeba przetestować na emulatorze lub na urządzeniu. I tu zaczynają się schody.&lt;/p&gt;

&lt;h4 id=&quot;problemy-z-debugowaniem-na-starym-sprz%C4%99cie&quot;&gt;Problemy z debugowaniem na starym sprzęcie&lt;/h4&gt;

&lt;p&gt;Nie wszystko wszystko wygląda tak kolorowo z testowaniem na starych Androidach, 
zwłaszcza jeśli nie działa i nie wiesz dlaczego, a logów nie ma... Nawet &lt;a href=&quot;/2016/05/18/code-coverage-w-karma.html&quot;&gt;dobre
pokrycie kodu testami jednostkowymi&lt;/a&gt; nie zawsze wszystko wyłapie, zwłaszcza 
gdy dopiero uczysz się danej biblioteki. Plugin dedykowany do współpracy z 
&lt;em&gt;console.log&lt;/em&gt; nie działa. Chrome Remote Debugging działa od Androida
4.4... Generalnie, nawet jeśli to co chcesz zrobić powinno działać, a problemem 
jest Twój błąd w kodzie to nie dowiesz się o tym bo logów ni ma...&lt;/p&gt;

&lt;h3 id=&quot;no-i-co-dalej%3F&quot;&gt;No i co dalej?&lt;/h3&gt;

&lt;p&gt;W &lt;a href=&quot;/2016/05/04/moscow-dla-drug-dose-framework.html&quot;&gt;planach rozwoju mojej aplikacji do obliczania dawek leków&lt;/a&gt; miałem dodanie 
pobierania danych z systemu plików urządzenia na którym aplikacja jest uruchamiana. 
Użytkownik miał mieć możliwość definiowania swoich własnych zestawów leków i dawek.
To niestety na razie nie będzie działało. Zestawy te muszą zostać zdefiniowane
przed zbudowaniem paczki i wraz z nią wgrane na urządzenie. Może to i lepiej,
zapobiegnie to różnym niebezpieczeństwom jakie musiałyby być brane pod uwagę gdyby
w ustawienia dawkowania mógł ingerować każdy kto ma dostęp do urządzenia. Do 
tego problemu wrócę gdy sam siebie przekonam do zmiany telefonu i będę miał
na czym testować.&lt;/p&gt;

&lt;p&gt;Podsumowując, &lt;strong&gt;nie potrzebujesz mieć wypasionego smartfona&lt;/strong&gt; by móc zacząć pisać
aplikacje na urządzenia mobilne. Mimo wszystko, &lt;strong&gt;warto jednak mieć w miarę aktualny
OS&lt;/strong&gt;, aby móc w pełni wykorzystać możliwości jakie dają nam biblioteki i narzędzia
przygotowane do debugowania aplikacji.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-28T19:30:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/28/szewc-ze-starym-smartfonem-chodzi.html</link>
            <atom:link href="http://lion.net.pl/2016/05/28/szewc-ze-starym-smartfonem-chodzi.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/28/szewc-ze-starym-smartfonem-chodzi.html</guid>
        </item>
                <item>
            <title>Tłumaczenie atrybutów w angular-gettext</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>JS</category>
                        <category>DDF</category>
                                    <content:encoded>&lt;p&gt;W &lt;a href=&quot;/2016/03/01/dam-sie-poznac.html&quot;&gt;mojej aplikacji&lt;/a&gt; wykorzystuję &lt;a href=&quot;/2016/04/26/i18n-z-angularjs-gettext.html&quot;&gt;bibliotekę angular-gettext&lt;/a&gt; w celu zapewnienia 
jej wsparcia dla I18N. Dzięki niej przygotowanie wielojęzykowej aplikacji w 
AngularJS jest w miarę proste. Biblioteka ta oferuje wiele możliwości oznaczania
tekstu jako &lt;em&gt;&quot;do przetłumaczenia&quot;&lt;/em&gt;. Istnieją jednak pewne pułapki o których więcej
informacji znajdziesz właśnie w tym wpisie.&lt;/p&gt;

&lt;h3 id=&quot;custom-annotations-w-angular-gettext&quot;&gt;Custom annotations w angular-gettext&lt;/h3&gt;

&lt;p&gt;Mechanizm &lt;a href=&quot;https://angular-gettext.rocketeer.be/dev-guide/custom-annotations/&quot;&gt;&lt;em&gt;custom annotations&lt;/em&gt;&lt;/a&gt; pozwala nam na zdefiniowanie własnych lub
wbudowanych atrybutów HTML które zostaną rozpoznane jako &quot;do przetłumaczenia&quot;
przez narzędzie &lt;em&gt;nggettext-extract&lt;/em&gt;. &lt;a href=&quot;/2016/04/26/i18n-z-angularjs-gettext.html&quot;&gt;Jak używać mechanizmu &lt;em&gt;custom annotations&lt;/em&gt; 
pisałem w poście opisującym angular-gettext&lt;/a&gt;. Jest to metoda określana jako 
optymalna dla tłumaczenia tekstów zawartych w atrybutach. Ma jednak swoje 
ograniczenia. Załóżmy że mamy taki kod:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;foo bar=&quot;abc&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;w wyniku &lt;em&gt;nggettext_extract&lt;/em&gt; otrzymamy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msgid &quot;abc&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tak samo dla:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;foo bar=&quot;abc&quot;&amp;gt;&amp;lt;/foo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ale dla:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;foo bar=&quot;abc&quot;&amp;gt;xyz&amp;lt;/foo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;otrzymamy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msgid &quot;xyz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jak widać &lt;strong&gt;mechanizm ten nie radzi sobie w niepustymi elementami HTML&lt;/strong&gt;. W 
przypadku gdy musimy przetłumaczyć atrybut takiego elementu &lt;strong&gt;należy skorzystać z 
filtra &lt;em&gt;translate&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;foo bar=&quot;{{ &quot;{{&#039;abc&#039;|translate &quot; }}}}&quot;&amp;gt;xyz&amp;lt;/foo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Problem ten był już &lt;a href=&quot;https://github.com/rubenv/angular-gettext/issues/226&quot;&gt;zgłaszany&lt;/a&gt; opiekunom biblioteki angular-gettext i czeka 
na rozwiązanie.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-27T17:00:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/27/tlumaczenie-atrybutow-html-w-angular-gettext.html</link>
            <atom:link href="http://lion.net.pl/2016/05/27/tlumaczenie-atrybutow-html-w-angular-gettext.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/27/tlumaczenie-atrybutow-html-w-angular-gettext.html</guid>
        </item>
            </channel>
</rss>