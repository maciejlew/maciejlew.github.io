<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>LionNet</title>
        <description>Programowanie, sieci komputerowe, informatyka.</description>      
        <link>http://lion.net.pl</link>
        <language>pl</language>
        <generator>Sculpin</generator>
        <category>IT</category>
        <atom:link href="http://lion.net.pl/blog/feed.xml" rel="self" type="application/rss+xml" />
                <item>
            <title>Nie używaj String|Numer|Boolean jako konstruktorów w JavaScript!</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>QA</category>
                        <category>JS</category>
                        <category>DDF</category>
                        <category>DSP2016</category>
                        <category>OOP</category>
                                    <content:encoded>&lt;p&gt;Śmieszne może się wydawać to że w języku obiektowym (czy też prototypowanym) jest 
możliwość utworzenia prostych obiektów opakowujących wartości proste, a 
jednocześnie wszyscy odradzają korzystania z nich. W tym wpisie dowiesz się dlaczego
tak właśnie dzieje się w JavaScript.&lt;/p&gt;

&lt;h3 id=&quot;typy-proste-w-js&quot;&gt;Typy proste w JS&lt;/h3&gt;

&lt;p&gt;JS posiada kilka prymitywów, czyli typów reprezentujących najprostsze i najczęściej
wykorzystywane w aplikacjach byty. Są to &lt;em&gt;boolean, number, string, null, undefined&lt;/em&gt;.
Pierwsze trzy możemy utworzyć wykorzystując konstruktory obiektów o tej samej nazwie:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var b1 = true;
var b2 = new Boolean(true);
var n1 = 1;
var n2 = new Number(1);
var s1 = &#039;a&#039;;
var s2 = new String(&#039;a&#039;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wszystko fajnie, dopóki nie musimy gdzieś w kodzie sprawdzić typu zmiennej by np.
&lt;a href=&quot;/2016/04/05/typy-wyjatkow-w-javascript.html&quot;&gt;rzucić odpowiednim wyjątkiem&lt;/a&gt;. Jeśli w naszej domenie zmienna powinna być 
stringiem to musimy to zrobić np. tak:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!(s instanceof String) || typeof s !== &#039;string&#039;) {
    throw new TypeError(&#039;Wrong type!&#039;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sprawdzenie samym &lt;em&gt;typeof&lt;/em&gt; nic nam niestety nie pomoże bo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typeof new String(&#039;a&#039;) === &#039;object&#039;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kolejne problemy pojawią się gdy będziemy chcieli porównać wartość zmiennej:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (s === &#039;a&#039;) {
    console.log(&#039;wartość s to a&#039;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;W przypadku gdy &lt;em&gt;s = s2&lt;/em&gt; powyższe sprawdzenie nam nie zadziała. W przypadku gdy 
&lt;em&gt;s = s1&lt;/em&gt;, zobaczymy w konsoli log. Możemy, co prawda, zrezygnować z operatora ===
i zastąpić go słabszym porównaniem ==, ale nie jest to zalecana praktyka która 
pociąga za sobą inne problemy.&lt;/p&gt;

&lt;p&gt;Przedstawione powyżej problemy są dwoma głównymi przyczynami dla których &lt;strong&gt;nie zaleca
się korzystać z wbudowanych w JS obiektów String, Number i Boolean&lt;/strong&gt;. &lt;a href=&quot;/2016/05/16/jshint-jakosc-kodu-js-pod-kontrola.html&quot;&gt;Narzędzie
do analizy statycznej kodu JSHint&lt;/a&gt; po natrafieniu na wykorzystanie w kodzie 
konstruktora &lt;em&gt;new&lt;/em&gt; powyższych typów zgłasza błąd, np: &lt;em&gt;&quot;Do not use Number as a 
constructor&quot;&lt;/em&gt;. Na szczęście wykrycie tego typu pułapek w kodzie i zastąpienie
ich typami prostymi jest bardzo łatwe, a może zaoszczędzić wielu nieporozumień
w przyszłości.&lt;/p&gt;

&lt;p&gt;Muszę się przyznać, że sam nadużywałem tworzenia obiektów Number i String. Robiłem 
to aby choć trochę zapanować nad tym co się dzieje ze zmiennymi w moim &lt;a href=&quot;https://github.com/maciejlew/drug-dose-framework&quot;&gt;projekcie
DDF&lt;/a&gt; i zrobić sobie substytut silnego typowania. Taki podejście niestety wiąże 
się z dużą ilością nadmiarowego kodu sprawdzającego typy zmiennych i konwertującego
prymitywy do obiektów je opakowujących. To się po prostu nie opłaca. Po 
refraktoryzacji do typów prostych kod wygląda bardziej czytelnie, jest go także
dużo mniej. Ilość przypadków testowych dla testów jednostkowych także spada.
Łatwiej jest zadbać o dobre &lt;a href=&quot;/2016/05/18/code-coverage-w-karma.html&quot;&gt;pokrycie kodu testami&lt;/a&gt;.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-19T19:00:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/19/nie-uzywaj-string-number-boolean-jako-konstruktorow-w-javascript.html</link>
            <atom:link href="http://lion.net.pl/2016/05/19/nie-uzywaj-string-number-boolean-jako-konstruktorow-w-javascript.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/19/nie-uzywaj-string-number-boolean-jako-konstruktorow-w-javascript.html</guid>
        </item>
                <item>
            <title>Code Coverage w Karma</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>QA</category>
                        <category>JS</category>
                        <category>DDF</category>
                        <category>DSP2016</category>
                                    <content:encoded>&lt;p&gt;Raporty pokrycia kodu testami jednostkowymi pozwalają szybko i przyjemnie przeanalizować
stan projektu. Wskazują miejsca gdzie kod nie jest dostatecznie przetestowany.
W tym wpisie dowiesz się jak wygenerować i jak interpretować &lt;em&gt;code coverage&lt;/em&gt; w 
narzędziu Karma dla JS.&lt;/p&gt;

&lt;h3 id=&quot;konfiguracja-karma-dla-code-coverage&quot;&gt;Konfiguracja Karma dla code coverage&lt;/h3&gt;

&lt;p&gt;Aby skorzystać z raportów pokrycia kodu testami jednostkowymi musimy doinstalować
bibliotekę &lt;em&gt;karma-coverage&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install karma-coverage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Następnie w konfiguracji, w pliku karma.conf.js bądź Gruntfile.js, należy dodać
następujące wpisy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plugins: [&#039;karma-coverage&#039;],
reporters: [&#039;coverage&#039;],
preprocessors: { &#039;*.js&#039;: [&#039;coverage&#039;] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Przykładowy wpis w Gruntfile.js, częściowo &lt;a href=&quot;/2016/03/03/yeoman-idziemy-na-front.html&quot;&gt;wygenerowany przez Yeoman&lt;/a&gt;, może 
wyglądać po wprowadzeniu powyższych zmian tak:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;karma: {
  options: {
    basePath: &#039;&#039;,
    frameworks: [&#039;jasmine&#039;],
    files: [
      &#039;&amp;lt;%= yeoman.app %&amp;gt;/&amp;lt;%= yeoman.scripts %&amp;gt;/**/*.js&#039;,
      &#039;&amp;lt;%= yeoman.test %&amp;gt;/mock/**/*.js&#039;,
      &#039;&amp;lt;%= yeoman.test %&amp;gt;/spec/**/*.js&#039;
    ],
    autoWatch: true,
    plugins: [
        &#039;karma-jasmine&#039;,
        &#039;karma-coverage&#039;,
        &#039;karma-phantomjs-launcher&#039;
    ],
    reporters: [&#039;dots&#039;, &#039;coverage&#039;],
    port: 8080,
    singleRun: false,
    preprocessors: {
      &#039;&amp;lt;%= yeoman.app %&amp;gt;/&amp;lt;%= yeoman.scripts %&amp;gt;/**/*.js&#039;: [&#039;coverage&#039;]
    },
    coverageReporter: {
      reporters: [
        { type: &#039;html&#039;, dir: &#039;coverage/&#039; },
        { type: &#039;text-summary&#039; }
      ]
    }
  },
  unit: {
    browsers: [&#039;PhantomJS&#039;],
    background: false
  },
  continuous: {
    browsers: [&#039;PhantomJS&#039;],
    singleRun: true
  }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Od tej chwili po wykonaniu testów Karma w folderze coverage przygotuje raporty dla
każdej przeglądarki dla której testy zostały przeprowadzone. W katalogach tych 
znajdziemy pliki &lt;em&gt;index.php&lt;/em&gt;, które po uruchomieniu w przeglądarce przedstawią
nam raport. Poniżej kilka przykładowych zrzutów ekranu z raportem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/DSP2016/karma-code-coverage-1.png&quot; alt=&quot;Karma code coverage report #1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/DSP2016/karma-code-coverage-2.png&quot; alt=&quot;Karma code coverage report #2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/DSP2016/karma-code-coverage-3.png&quot; alt=&quot;Karma code coverage report #3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Na zrzutach widzimy, że raport HTML pozwala nam szybko przejrzeć strukturę projektu,
odnaleźć pliki dla których brakuje bądź jest za mało testów. &lt;strong&gt;Mamy wyszczególnione
pokrycie testami linii, funkcji oraz gałęzi&lt;/strong&gt;, czyli ścieżek którymi może nasz kod 
przejść od startu do końca podczas jego wykonywania.&lt;/p&gt;

&lt;p&gt;Dodatkowo, po przejściu do konkretnego pliku, Karma a właściwie wykorzystywane 
przez nią w tle narzędzie o nazwie Istanbul, wskaże nam podejrzane rozgałęzienia 
kodu, oznaczając je symbolami &lt;em&gt;I (if path not taken)&lt;/em&gt; lub &lt;em&gt;E (else path not taken)&lt;/em&gt;.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-18T15:30:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/18/code-coverage-w-karma.html</link>
            <atom:link href="http://lion.net.pl/2016/05/18/code-coverage-w-karma.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/18/code-coverage-w-karma.html</guid>
        </item>
                <item>
            <title>JSHint - jakość kodu JS pod kontrolą</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>QA</category>
                        <category>JS</category>
                        <category>DDF</category>
                        <category>DSP2016</category>
                                    <content:encoded>&lt;p&gt;JavaScript pozwala na wiele. Pozwala także zrobić sobie śmietnik w aplikacji.
Z czasem każda zaniedbana aplikacja będzie zmierzać w kierunku nieczytelnej papki
kodu, coraz trudniej będzie się w tym wszystkim połapać, a zwłaszcza gdy pracuje 
nad nią sztab ludzi. Entropia projektu rośnie. Na szczęście są rozwiązania 
pozwalające na &lt;strong&gt;ujednolicenie stylu kodowania w JS, wyłapanie błędogennych 
instrukcji, wskazanie skomplikowanych fragmentów kodu&lt;/strong&gt;. W tym wpisie przeczytasz 
jak ułatwić sobie codzienną pracę nad kodem JS wykorzystując do tego &lt;a href=&quot;http://jshint.com&quot;&gt;narzędzie 
JSHint&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;a-mo%C5%BCe-jslint%3F&quot;&gt;A może JSLint?&lt;/h3&gt;

&lt;p&gt;JSHint i JSLint są bardzo zbliżonymi narzędziami. Jak można się dowiedzieć w 
Internetach, JSHint powstał w wyniku niezadowolenia brakiem możliwości konfiguracji
JSLint. Problem ten już został rozwiązany w JSLint, ale konkurencyjne narzędzie
pozostało. JSHint powstał na przełomie 2010/2011 roku. Był rozwijany przez te 
kilka ostatnich lat, a wiele projektów pisanych w JS zaczęło go używać do 
sprawdzania jakości wytworzonego kodu. Na chwilę obecną &lt;a href=&quot;http://jshint.com/docs/options/&quot;&gt;JSHint obsługuje ponad 
80 opcji konfiguracyjnych&lt;/a&gt;, a autorzy zachęcają do dodawania kolejnych jeśli 
dla kogoś to jeszcze za mało. &lt;strong&gt;Zainteresowanie JSHint ciągle rośnie&lt;/strong&gt;, co może 
potwierdzić poniższy wykres:&lt;/p&gt;

&lt;noscript&gt;
W tym miejscy znajduje się element wymagający do wyświetlenia włączonej obsługi 
JavaScript w przeglądarce.
&lt;/noscript&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;//www.google.pl/trends/embed.js?hl=pl&amp;q=jslint,+jshint&amp;cid=TIMESERIES_GRAPH_0&amp;export=5&amp;w=600&amp;h=330&quot;&gt;&lt;/script&gt;

&lt;h3 id=&quot;jak-u%C5%BCywa%C4%87-jshint%3F&quot;&gt;Jak używać JSHint?&lt;/h3&gt;

&lt;p&gt;Narzędzia tego możemy używać na kilka sposobów. Pierwszym i najwygodniejszym na
początek jest wejście na &lt;a href=&quot;http://jshint.com&quot;&gt;jego stronę&lt;/a&gt; i skorzystanie z analizy online kodu.
Gdy się już przekonasz do jego zalet, o wiele lepszym wyjściem jest lokalna 
instalacja tego dodatku. Można to zrobić przy pomocy NPM, globalnie lub per 
projekt.&lt;/p&gt;

&lt;p&gt;Zainstalowane JSHint można wykorzystać albo uruchamiając je per wybrany plik lub
dla całego projektu. Uruchamianie dla projektu jest o wiele wygodniejsze gdy 
przygotuje się już swój własny zestaw reguł. &lt;strong&gt;Reguły te zapisuje się w plikach
.jshintrc&lt;/strong&gt;. JSHint jest na tyle sprytny, że kaskadowo przeszukuje strukturę 
projektu szukając plików reguł znajdujących się najbliżej analizowanego kodu.
Jeśli nic nie zostanie znalezione zostanie użyty globalny &lt;em&gt;.jshintrc&lt;/em&gt; znajdujący 
się w katalogu domowym użytkownika lub zaaplikowany zostanie domyślny zestaw reguł.&lt;/p&gt;

&lt;p&gt;W moim projekcie &lt;a href=&quot;/2016/03/03/yeoman-idziemy-na-front.html&quot;&gt;Yeoman wygenerował pliki .jshintrc automatycznie&lt;/a&gt; uzupełniając 
je w popularnymi zestawami reguł. Przykładowo główny plik zestawu reguł wygląda 
tak:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;node&quot;: true,
  &quot;browser&quot;: true,
  &quot;esnext&quot;: true,
  &quot;bitwise&quot;: true,
  &quot;camelcase&quot;: true,
  &quot;curly&quot;: true,
  &quot;eqeqeq&quot;: true,
  &quot;immed&quot;: true,
  &quot;indent&quot;: 2,
  &quot;latedef&quot;: true,
  &quot;newcap&quot;: true,
  &quot;noarg&quot;: true,
  &quot;quotmark&quot;: &quot;single&quot;,
  &quot;regexp&quot;: true,
  &quot;undef&quot;: true,
  &quot;unused&quot;: true,
  &quot;strict&quot;: true,
  &quot;trailing&quot;: true,
  &quot;smarttabs&quot;: true,
  &quot;globals&quot;: {
    &quot;angular&quot;: false,
    &quot;cordova&quot;: false,
    &quot;StatusBar&quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Odgadnięcie znaczenia większość tych opcji powinno być bardzo łatwe i intuicyjne,
szczegółowy ich opis można znaleźć w &lt;a href=&quot;http://jshint.com/docs/options/&quot;&gt;wykazie dostępnych opcji JSHint&lt;/a&gt;. Yeoman
wygenerował mi także zestaw reguł dla plików testów:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;node&quot;: true,
  &quot;browser&quot;: true,
  &quot;esnext&quot;: true,
  &quot;bitwise&quot;: true,
  &quot;camelcase&quot;: true,
  &quot;curly&quot;: true,
  &quot;eqeqeq&quot;: true,
  &quot;immed&quot;: true,
  &quot;indent&quot;: 2,
  &quot;latedef&quot;: true,
  &quot;newcap&quot;: true,
  &quot;noarg&quot;: true,
  &quot;quotmark&quot;: &quot;single&quot;,
  &quot;regexp&quot;: true,
  &quot;undef&quot;: true,
  &quot;unused&quot;: true,
  &quot;strict&quot;: true,
  &quot;trailing&quot;: true,
  &quot;smarttabs&quot;: true,
  &quot;globals&quot;: {
    &quot;after&quot;: false,
    &quot;afterEach&quot;: false,
    &quot;angular&quot;: false,
    &quot;before&quot;: false,
    &quot;beforeEach&quot;: false,
    &quot;browser&quot;: false,
    &quot;describe&quot;: false,
    &quot;expect&quot;: false,
    &quot;inject&quot;: false,
    &quot;it&quot;: false,
    &quot;jasmine&quot;: false,
    &quot;spyOn&quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jak widać w większości się one powielają. Różnica występuje jedynie w obiekcie 
&lt;em&gt;globals&lt;/em&gt;, w którym definiuje się nazwy zmiennych globalnych dostarczanych przez
środowisko przeglądarki, framework lub właśnie przez biblioteki do testowania
kodu JS. Widzimy tu więc znane z &lt;a href=&quot;/2016/03/07/zapach-jasminu.html&quot;&gt;frameworka Jasmine&lt;/a&gt; zmienne takie jak:
&lt;em&gt;jasmine&lt;/em&gt;, &lt;em&gt;after&amp;#42;&lt;/em&gt;, &lt;em&gt;before&amp;#42;&lt;/em&gt;, &lt;em&gt;describe&lt;/em&gt;, &lt;em&gt;expect&lt;/em&gt;, &lt;em&gt;it&lt;/em&gt;, itd. Te zmienne nie 
zostaną potraktowane jako niezdefiniowane gdy JSHint napotka je podczas analizy 
plików testów.&lt;/p&gt;

&lt;p&gt;Możliwe jest także definiowanie reguł JSHint bezpośrednio w pliku z analizowanym 
kodem. Robi się to przy pomocy odpowiednich komentarzy, Na przykład &lt;a href=&quot;/2016/04/26/i18n-z-angularjs-gettext.html&quot;&gt;biblioteka 
angular-gettext&lt;/a&gt; podczas generowania tłumaczeń dodaje taki oto komentarz:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&#039;gettext&#039;).run([&#039;gettextCatalog&#039;, function (gettextCatalog) {
/* jshint -W100 */
    gettextCatalog.setStrings(&#039;pl_PL&#039;, {&quot;Type drug name&quot;:&quot;Wpisz nazwę leku&quot;});
/* jshint +W100 */
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Widzimy tu wyłączenie opcji &lt;em&gt;W100&lt;/em&gt; dla wybranego fragmentu kodu, a następnie jej
ponowne włączenie. Nie polecałbym jednak tej metody bo takie komentarze w kodzie
także zaciemniają jego obraz.&lt;/p&gt;

&lt;h3 id=&quot;ciekawe-problemy&quot;&gt;Ciekawe problemy&lt;/h3&gt;

&lt;h4 id=&quot;automatycznie-generowane-pliki&quot;&gt;Automatycznie generowane pliki&lt;/h4&gt;

&lt;p&gt;Czasami w źródłach aplikacji znajdują się automatycznie generowane pliki, 
dostarczane przez zewnętrzne oprogramowanie, które nie stosują się do naszych 
reguł JSHint. Mamy wtedy 3 wyjścia z tej sytuacji:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ingerować w kod biblioteki i poprawić jej generator kodu wedle naszego uznania;&lt;/li&gt;
&lt;li&gt;zmieniać za każdym razem generowane pliki dodając odpowiednie komentarze wyłączające
wybrane zestawy reguł;&lt;/li&gt;
&lt;li&gt;nie sprawdzać wcale tych plików, zakładając że są dobre.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Rozwiązanie 3. wydaje się być najbardziej rozsądne. Na szczęście JSHint pozwala
na takie wyjątki, wystarczy że w katalogu projektu utworzymy plik &lt;em&gt;.jshintignore&lt;/em&gt;,
w którym umieścimy ścieżki do ignorowanych plików - problem z głowy.&lt;/p&gt;

&lt;h4 id=&quot;ma%C5%82o-intuicyjne-opisy-b%C5%82%C4%99d%C3%B3w-i-ostrze%C5%BCe%C5%84%2C-brakuj%C4%85ce-opcje&quot;&gt;Mało intuicyjne opisy błędów i ostrzeżeń, brakujące opcje&lt;/h4&gt;

&lt;p&gt;Większość błędów i ostrzeżeń generowanych podczas analizy kodu narzędziem JSHint
posiada opisy które jednoznacznie pozwalają na wskazanie reguły której powiązane
z nimi wyrażenia nie spełniły. Czasami jednak zdarza się, że dostaniemy coś co do 
niczego nie pasuje, np: &lt;em&gt;&quot;Do not use Number as a constructor&quot;&lt;/em&gt;. Powiedzmy że chcemy
wyłączyć tą regułę. Jak ją znaleźć? Dobrze jest włączyć bardziej gadatliwy tryb
działania JSHint. Robimy to dodając opcję &lt;em&gt;--verbose&lt;/em&gt;. Otrzymamy wtedy kod 
błędu/ostrzeżenia, w tym przypadki &lt;em&gt;W053&lt;/em&gt;. Teraz należy przeszukać całe &lt;a href=&quot;https://github.com/jshint/jshint&quot;&gt;repozytorium
JSHint&lt;/a&gt;. Pozwoli to namierzyć kawałek kodu który odpowiedzialny jest za 
przygotowanie komunikatu. Po krótkiej analizie okazuje się że nie ma opcji 
pozwalającej na wyłączenie tego ostrzeżenia.&lt;/p&gt;

&lt;h4 id=&quot;fa%C5%82szywe-ostrze%C5%BCenia-o-brakuj%C4%85cych-kasach&quot;&gt;Fałszywe ostrzeżenia o brakujących kasach&lt;/h4&gt;

&lt;p&gt;Czasami dla lepszej czytelności kodu wynosimy definicje klas do osobnych plików,
a wykorzystujemy je w zupełnie innych częściach aplikacji, w innych plikach.
Odpowiednio dołączone pliki lub ich scalenie przed wysłaniem do przeglądarki 
powodują że wszystko działa tak jak należy. Niestety JSHint o tym nie wie i z 
tego powodu ostrzega nas, np: &lt;em&gt;&quot;&#039;DoseComplexParameters&#039; is not defined.&quot;&lt;/em&gt;. Aby 
się pozbyć tych fałszywie pozytywnych ostrzeżeń należy dodać w opcji &lt;em&gt;globals&lt;/em&gt;
swoje nazwy klas.&lt;/p&gt;

&lt;h3 id=&quot;czy-jshint-jest-dla-wszystkich%3F&quot;&gt;Czy JSHint jest dla wszystkich?&lt;/h3&gt;

&lt;p&gt;Zdecydowanie tak. Pomimo kilku opisanych powyżej problemów jest to narzędzie 
bardzo pomocne oraz intuicyjne w użyciu. Możliwość automatyzacji analizy statycznej 
kodu bardzo pomaga w jego utrzymaniu i dalszym rozwoju. Mogę polecić JSHint każdemu
kto chce dbać o stan swojego projektu i myśli o jego przyszłości w dalszej
perspektywie niż tylko do momentu gdy klient zapłaci fakturę.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-16T18:00:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/16/jshint-jakosc-kodu-js-pod-kontrola.html</link>
            <atom:link href="http://lion.net.pl/2016/05/16/jshint-jakosc-kodu-js-pod-kontrola.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/16/jshint-jakosc-kodu-js-pod-kontrola.html</guid>
        </item>
                <item>
            <title>Quality Meetup #8</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>QA</category>
                                    <content:encoded>&lt;p&gt;Minęło trochę czasu od &lt;a href=&quot;/2016/02/13/quality-meetup-7.html&quot;&gt;poprzedniego spotkania Quality Meetup&lt;/a&gt; na Śląsku. 
Po trzech miesiącach zorganizowano kolejne, ósme, spotkanie ludzi zainteresowanych
jakością wytwarzanego oprogramowania. Poniżej możesz przeczytać moją krótką relację
z tego wydarzenia.&lt;/p&gt;

&lt;h3 id=&quot;poznaj-context-driven-testing&quot;&gt;Poznaj Context-Driven Testing&lt;/h3&gt;

&lt;p&gt;Idąc na to spotkanie QM nie wiedziałem za bardzo o co będzie chodziło z tym całym
CDT. Pierwszy raz spotkałem się z tym terminem. Jak pewnie wielu innych, kojarzyłem
go z takimi technikami jak TDD, BDD itp. Michał Stryjak przedstawił nam czym jest
to całe CDT. Jest to koncepcja mówiąca że należy testować w sposób najlepiej
pasujący do testowanego kontekstu. Według tej teorii nie ma takiego czegoś, co 
można by nazwać metodą testowania dobrą na wszystko. Każda  z nich ma swoje wady i
zalety, które należy poznać i dobrać tak, aby wnosiły wartość dodaną do całego
projektu. Michał przedstawił nam m.in. genealogię CDT oraz jej podstawowe zasady, 
tj:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wartość metody testowania zależy od kontekstu&lt;/li&gt;
&lt;li&gt;istnieją dobre metody testowania w danym kontekście, ale nie oznacza to że
będą dobre w innym&lt;/li&gt;
&lt;li&gt;ludzie zaangażowaniu w testowany produkt są najważniejszym elementem kontekstu&lt;/li&gt;
&lt;li&gt;z czasem projektu rozwijają się w nieprzewidywalny na ich starcie sposób&lt;/li&gt;
&lt;li&gt;produkt ma być rozwiązaniem problemu, jeśli problem nie został rozwiązany to
produkt nie działa&lt;/li&gt;
&lt;li&gt;testowanie jest wymagającym złożonym procesem intelektualnym&lt;/li&gt;
&lt;li&gt;właściwe przetestowanie produktu wymaga właściwego jego osądu oraz kompetencji
pozwalających na dobranie odpowiednich technik testowania na odpowiednim etapie 
rozwoju produktu&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Te definicje wydają się tak oczywiste, że gdy się je przeczyta ma się wrażenie że
już dawno postępowało się zgodnie z CDT, tylko się o tym nie wiedziało.&lt;/p&gt;

&lt;p&gt;Więcej informacji o CDT można znaleźć m.in. na &lt;a href=&quot;http://www.slideshare.net/FutureProcessing/micha-stryjak-poznaj-contextdriven-testing&quot;&gt;slajdach z prezentacji o CDT&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;testy-bezpiecze%C5%84stwa---teoria-a-praktyka&quot;&gt;Testy bezpieczeństwa - teoria a praktyka&lt;/h3&gt;

&lt;p&gt;Kolejna prezentacja była bardziej praktyczna i widowiskowa. Michał Sajdak przekazał
nam sporo cennych informacji nt. bezpieczeństwa systemów webowych. Część z 
informacji można było już wcześniej przeczytać na łamach czasopisma Programista
w artykułach przygotowanych przez Michała bądź w prowadzonym przez niego e-zinie
Sekurak. Ale nic tak nie uruchamia wyobraźni i chęci uczenia się jak przykłady
obejrzane na żywo. Prelegent pokazał nam kilka fajnych usług webowych pozwalających
szybko wykryć inne domeny hostowane na tym samym hoście co interesująca atakującego
aplikacja. Dowiedzieliśmy się także o jak wykonać bash shellshock oraz XXE na 
podatnej stronie internetowej. Było także trochę o znanych wpadkach producentów
oprogramowania i sprzętu sieciowego oraz o ich podejściu do wykrywanych przez
zewnętrznych niezależnych testerów bezpieczeństwa luk. Była to bardzo ciekawa 
prezentacja z której &lt;a href=&quot;http://www.slideshare.net/FutureProcessing/micha-sajdak-testy-bezpieczestwa-teoria-a-praktyka&quot;&gt;slajdy także można zobaczyć w Internecie&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;quality-excites-2016&quot;&gt;Quality Excites 2016&lt;/h3&gt;

&lt;p&gt;Podczas spotkania zostało zapowiedziane znane chyba wszystkim śląskim testerom
najpopularniejsze darmowe cykliczne wydarzenie w okolicy, czyli &lt;a href=&quot;https://qualityexcites.pl/&quot;&gt;Quality Excites&lt;/a&gt;.
Tym razem będziemy mogli się spotkać i posłuchać prelekcji bądź wziąć udział w
warsztatach już 25 czerwca. Zapisy niebawem. Bądźcie czujni!&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-14T13:10:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/14/quality-meetup-8.html</link>
            <atom:link href="http://lion.net.pl/2016/05/14/quality-meetup-8.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/14/quality-meetup-8.html</guid>
        </item>
                <item>
            <title>Przykład dobrego changeloga</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>DDF</category>
                                    <content:encoded>&lt;p&gt;Po wstępie do &lt;a href=&quot;/2016/05/05/jak-robic-dobry-changelog.html&quot;&gt;tematu tworzenia dobrych changelogów&lt;/a&gt; przyszedł czas na praktyczny
przykład.&lt;/p&gt;

&lt;h3 id=&quot;przyk%C5%82ad-dobrego-dziennika-zmian&quot;&gt;Przykład dobrego dziennika zmian&lt;/h3&gt;

&lt;p&gt;Dla przypomnienia, dobry dziennik powinien być prowadzony w Markdown, mieć 
przejrzyście wydzielone sekcje, wspierać &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt; oraz daty w 
formacie &lt;em&gt;YYYY-MM-DD&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## [Unreleased]

## [0.2.0] - 2016-05-11
### Added
- MSCW requirements document
- I18N: en, pl, de

### Changed
- alerts to Ionic modals

## [0.1.0] - 2016-04-13
### Added
- drug list view
- drug details view
- dose calculator view
- drugs data sets loader
- drug dose calculation algorithms
- UML class diagram
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jest to także dobra okazja by pochwalić się że DDF doczekał się wersji 0.2.0 oraz 
że zostało wdrożone jedno (choć mało istotnie bo oznaczone jako COULD) &lt;a href=&quot;/2016/05/04/moscow-dla-drug-dose-framework.html&quot;&gt;wymaganie 
opisane w dokumencie MoSCoW&lt;/a&gt; czyli wsparcie dla I18N.&lt;/p&gt;

&lt;p&gt;Zmiany w DDF można także śledzić w jego &lt;a href=&quot;https://github.com/maciejlew/drug-dose-framework&quot;&gt;repozytorium na GitHubie&lt;/a&gt;.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-11T23:25:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/11/przyklad-dobrego-changeloga.html</link>
            <atom:link href="http://lion.net.pl/2016/05/11/przyklad-dobrego-changeloga.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/11/przyklad-dobrego-changeloga.html</guid>
        </item>
                <item>
            <title>Zmiana języka &#039;on the fly&#039; w Ionic i angular-gettext</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>DDF</category>
                        <category>JS</category>
                                    <content:encoded>&lt;p&gt;Pisałem niedawno o &lt;a href=&quot;/2016/04/26/i18n-z-angularjs-gettext.html&quot;&gt;wdrażaniu I18N w aplikacji&lt;/a&gt;. Tym razem pokaże jak zrobić 
działający &quot;on the fly&quot; kontroler do zmiany języka w aplikacji napisanej przy pomocy
frameworka Ionic.&lt;/p&gt;

&lt;h3 id=&quot;wczytywanie-ustawie%C5%84-j%C4%99zykowych-podczas-uruchamiania&quot;&gt;Wczytywanie ustawień językowych podczas uruchamiania&lt;/h3&gt;

&lt;p&gt;Podczas uruchamiania aplikacji dobrze by było pobrać język w jakim użytkownik 
życzy sobie jej używać. &lt;strong&gt;Ustawienia językowe możemy zapisać np. w local storage&lt;/strong&gt;.
Przyjmijmy że nasza aplikacja obsługuje 3 języki: angielski, polski i niemiecki.
Przy takiej konfiguracji nasz moduł może wyglądać następująco:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = angular.module(&#039;DrugDoseFrameworkApp&#039;, dependencies).run(function ($ionicPlatform, gettextCatalog) {

    var language = &#039;en_EN&#039;;
    if (window.localStorage.getItem(&#039;language&#039;)) {
        language = window.localStorage.getItem(&#039;language&#039;);
    } else {
        switch (window.navigator.language.substr(0, 2)) {
            case &#039;pl&#039;:
                language = &#039;pl_PL&#039;;
                break;
            case &#039;de&#039;:
                language = &#039;de_DE&#039;;
                break;
        }
        localStorage.setItem(&#039;language&#039;, language);
    }
    gettextCatalog.setCurrentLanguage(language);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Widzimy tu, że domyślnie ładowany jest język angielski. Następnie próbujemy wykryć
czy użytkownik już zapisał cokolwiek w zmiennej przechowywanej lokalnie nt.
preferowanego języka. Jeśli i to się nie powiedzie, to próbujemy ustalić język
na podstawie ustawień przeglądarki.&lt;/p&gt;

&lt;h3 id=&quot;kontroler-zmiany-j%C4%99zyka&quot;&gt;Kontroler zmiany języka&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;drugDoseFrameworkControllers.controller(&#039;LanguageCtrl&#039;, function ($scope, $state, gettextCatalog) {

    $scope.language = window.localStorage.getItem(&#039;language&#039;);

    $scope.changeLanguage = function() {
        window.localStorage.setItem(&#039;language&#039;, $scope.language);
        gettextCatalog.setCurrentLanguage($scope.language);
        $state.go(&#039;drugs&#039;);
    };

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kontroler ten posiada jedną zmienną, określająca wybrany język oraz jedną prostą
metodę pozwalającą na jego zmianę. Nowe ustawienia są zapisywane w localStorage.&lt;/p&gt;

&lt;h3 id=&quot;widok-zmiany-j%C4%99zyka&quot;&gt;Widok zmiany języka&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ion-view view-title=&quot;Language settings&quot;&amp;gt;
&amp;lt;ion-content ng-controller=&quot;LanguageCtrl&quot;&amp;gt;
    &amp;lt;ion-list&amp;gt;
        &amp;lt;ion-radio ng-model=&quot;language&quot; ng-value=&quot;&#039;en_EN&#039;&quot; ng-change=&quot;changeLanguage()&quot;&amp;gt;
            english
        &amp;lt;/ion-radio&amp;gt;
        &amp;lt;ion-radio ng-model=&quot;language&quot; ng-value=&quot;&#039;pl_PL&#039;&quot; ng-change=&quot;changeLanguage()&quot;&amp;gt;
            polish
        &amp;lt;/ion-radio&amp;gt;
        &amp;lt;ion-radio ng-model=&quot;language&quot; ng-value=&quot;&#039;de_DE&#039;&quot; ng-change=&quot;changeLanguage()&quot;&amp;gt;
            german
        &amp;lt;/ion-radio&amp;gt;
    &amp;lt;/ion-list&amp;gt;
&amp;lt;/ion-content&amp;gt;
&amp;lt;/ion-view&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Widok zmiany języka jest bardzo prosty i składa się z dyrektyw Ionic za którymi
kryją się proste radio inputy. Bindujemy tu model &lt;em&gt;language&lt;/em&gt; z tymi inputami oraz
podpinamy metodę &lt;em&gt;changelanguage&lt;/em&gt; pod zdarzenie zmiany stanu tych kontrolek.&lt;/p&gt;

&lt;h3 id=&quot;konfiguracja-stateprovider%27a&quot;&gt;Konfiguracja stateProvider&#039;a&lt;/h3&gt;

&lt;p&gt;Jeśli nasza aplikacja Ionic składa się z wielu widoków &lt;em&gt;ion-view&lt;/em&gt; bądź &lt;em&gt;ion-nav-view&lt;/em&gt;
i chcemy aby język ustawił się od razu, a nie po kolejnym uruchomieniu aplikacji
(bądź odświeżeniu strony) to musimy wyłączyć cache dla tych widoków. Możemy to 
zrobić w module konfiguracji aplikacji w następujący sposób:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.config(function ($stateProvider, $urlRouterProvider) {
    $stateProvider.state(&#039;drugs&#039;, {
        cache: false,
        url: &#039;/drugs/&#039;,
        templateUrl: &#039;partials/drug-list.html&#039;,
        controller: &#039;DrugListCtrl&#039;
    }).state(&#039;drug-details&#039;, {
        cache: false,
        url: &#039;/drugs/:drugId&#039;,
        templateUrl: &#039;partials/drug-details.html&#039;,
        controller: &#039;DrugDetailsCtrl&#039;
    }).state(&#039;language&#039;, {
        cache: false,
        url: &#039;/drugs/language/&#039;,
        templateUrl: &#039;partials/language.html&#039;,
        controller: &#039;LanguageCtrl&#039;
    }).state(&#039;drug-dose&#039;, {
        cache: false,
        url: &#039;/drugs/dose/:drugId&#039;,
        templateUrl: &#039;partials/drug-dose.html&#039;,
        controller: &#039;DrugDoseCtrl&#039;
    });
    $urlRouterProvider.otherwise(&quot;/drugs/&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;podsumowanie&quot;&gt;Podsumowanie&lt;/h3&gt;

&lt;p&gt;Dodanie obsługi wielu języków w aplikacji Ionic jest bardzo proste jeśli skorzysta 
się z biblioteki angular-gettext. Ilość kodu do tego potrzebna jest bardzo mała,
a sama implementacja zrozumiała dla każdego, nawet początkującego programisty
JS. Jedyną trudnością może być znalezienie informacji o konieczności &lt;a href=&quot;http://ionicframework.com/docs/api/directive/ionNavView/&quot;&gt;wyłączenia
cache widoków Ionic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Zachęcam do przejrzenia kodu mojej &lt;a href=&quot;https://github.com/maciejlew/drug-dose-framework&quot;&gt;aplikacji konkursowej DDF&lt;/a&gt;, w której 
zaimplementowałem w podany wyżej sposób I18N.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-10T20:20:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/10/zmiana-jezyka-on-the-fly-w-ionic-i-angular-gettext.html</link>
            <atom:link href="http://lion.net.pl/2016/05/10/zmiana-jezyka-on-the-fly-w-ionic-i-angular-gettext.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/10/zmiana-jezyka-on-the-fly-w-ionic-i-angular-gettext.html</guid>
        </item>
                <item>
            <title>Jak robić dobry changelog?</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>DDF</category>
                                    <content:encoded>&lt;p&gt;Jeśli zastanawiasz się jak przygotować dobry, ustandaryzowany i czytelny changelog
Twojej aplikacji to w tym wpisie najdziesz to czego szukasz.&lt;/p&gt;

&lt;h2 id=&quot;changelog&quot;&gt;Changelog&lt;/h2&gt;

&lt;p&gt;Dziennik zmian jest dokumentem często robionym po macoszemu, z założeniem że i
tak nikt go nie przeczyta i nikomu się nie przyda. A to duży błąd. Dobrze 
przygotowany changelog pomaga. I to bardzo. Dzięki niemu szybko ustalisz co
nowego zostało dodane w danej wersji, co zostało naprawione, usunięte lub zastąpione.
Łatwiej również będzie Ci zaspokoić ciekawość kolegów z działu handlowego lub 
samych klientów podsyłając im gotowy i czytelny dla nich dokument. Zyskasz na 
czasie. Nie będziesz musiał wszystkie pamiętać lub sprawdzać bezpośrednio w 
kodzie bądź repozytorium.&lt;/p&gt;

&lt;h3 id=&quot;jak-robi%C4%87-dobry-changelog%3F&quot;&gt;Jak robić dobry changelog?&lt;/h3&gt;

&lt;p&gt;Pisanie changeloga to proces ciągły. Dobrze by było gdyby każdy bez chwili 
zastanowienia wiedział jak opisać swoją zmianę. Na szczęście ktoś pomyślał za 
Nas i nie musimy wymyślać koła od nowa. &lt;a href=&quot;http://keepachangelog.com/&quot;&gt;Projekt Keep a CHANGELOG&lt;/a&gt; powstał, 
jak sama nazwa wskazuje, by ułatwić wszystkim utrzymywanie ustandaryzowanego, 
czytelnego dziennika zmian. Projekt ten definiuje kilka zasad które są łatwe do 
zapamiętania i wdrożenia:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;najważniejsza jest czytelność&lt;/li&gt;
&lt;li&gt;należy wykorzystywać Markdown&lt;/li&gt;
&lt;li&gt;należy dzielić dokument na sekcje - sekcja = wersja projektu&lt;/li&gt;
&lt;li&gt;porządek ma być odwrotnie chronologiczny&lt;/li&gt;
&lt;li&gt;daty należy zapisywać w formacie &lt;em&gt;YYYY-MM-DD&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;należy numerować zgodnie z &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;należy odpowiednio formować i formatować każdą z wersji (sekcji):

&lt;ul&gt;
&lt;li&gt;powinna mieć określoną datę wydania&lt;/li&gt;
&lt;li&gt;powinna grupować zmiany według schematu:

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Added&lt;/em&gt; nowe ficzery&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Changed&lt;/em&gt; rzeczy zmienione&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Deprecated&lt;/em&gt; funkcjonalności które mają w przyszłości zostać wycofane&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Removed&lt;/em&gt; usunięte funkcje programu&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Fixed&lt;/em&gt; naprawione bugi&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Security&lt;/em&gt; ważne dla bezpieczeństwa fixy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;dodatkowo należy zdefiniować sekcję &lt;em&gt;Unreleased&lt;/em&gt; dla wersji niestabilnej&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;po-co-robi%C4%87-changelog%3F&quot;&gt;Po co robić changelog?&lt;/h3&gt;

&lt;p&gt;Te kilka prostych zasad powoduje że changelog staje się czytelny dla wszystkich
jego użytkowników. Dodatkowo, dzięki zastosowaniu Markdown, może łatwo zostać 
skonwertowany do HTML bądź PDF co pozwoli na jego przedstawienie klientowi w 
bardziej biznesowej formie. Taki przygotowany w Markdown changelog ładnie będzie
także wyglądał na GitHubie. Dziennik zmian, podobnie jak np. &lt;a href=&quot;/2016/04/29/podroz-na-wschod-roadmap-z-moscow.html&quot;&gt;roadmap&lt;/a&gt; i inne
około-projektowe dokumenty, może wzbogacić Twój projekt i warto poświęcić mu klika 
chwil. Zwróci Ci się to!&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-05T22:15:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/05/jak-robic-dobry-changelog.html</link>
            <atom:link href="http://lion.net.pl/2016/05/05/jak-robic-dobry-changelog.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/05/jak-robic-dobry-changelog.html</guid>
        </item>
                <item>
            <title>MoSCoW dla Drug Dose Framework</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>DDF</category>
                                    <content:encoded>&lt;p&gt;Pisałem ostatnio o &lt;a href=&quot;/2016/04/29/podroz-na-wschod-roadmap-z-moscow.html&quot;&gt;zaletach metody MoSCoW&lt;/a&gt; i o proponowanym przeze mnie szablonie
dokumentu dla tej metody. Pora zaprezentować jak taki dokument może wyglądać w 
rzeczywistości, na przykładzie mojej aplikacji DDF.&lt;/p&gt;

&lt;h3 id=&quot;roadmap-dla-ddf&quot;&gt;Roadmap dla DDF&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# Requirements for project &#039;Drug Dose Framework&#039;

## MUST have:
- drugs set and drug details file format specyfication [0.1.0]
- drug list view [0.1.0]
- drug details view [0.1.0]
- drug dose calculator view [0.1.0]
- function to calculate valid doses for simple and complex dose schemas [0.1.0]

## SHOULD have:
- function to let user choose drugs set from device file storage
- option to validate user&#039;s sets and show mistkes
- loading screen
- program icon

## COULD have:
- multi-language support
- searching history
- dose calculation history
- function to let users change language at run time

## WON&#039;T have:
- built-in drug sets and drug details editor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jak widać lista jest bardzo czytelna. Szybko można wyszukać na niej co już zostało
zrobione, a co jest do zrobienia w najbliższym czasie. Oznaczanie zrealizowanych
zadań numerami wersji w których zmiany te zostały wydane pomaga w szybkim przeglądzie
postępu prac nad projektem.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-05-04T20:30:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/05/04/moscow-dla-drug-dose-framework.html</link>
            <atom:link href="http://lion.net.pl/2016/05/04/moscow-dla-drug-dose-framework.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/05/04/moscow-dla-drug-dose-framework.html</guid>
        </item>
                <item>
            <title>Podróż na wschód - roadmap z MoSCoW</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>DDF</category>
                                    <content:encoded>&lt;p&gt;Nawet w najprostszych projektach warto spisać raport z założonych wymagań, tzw. roadmap.
Czytając ten wpis dowiesz się jak zrobić to łatwo, tanio i przyjemnie wykorzystując
metodę MoSCoW.&lt;/p&gt;

&lt;p&gt;Analiza wymagań jest jednym z najważniejszych etapów każdego projektu. I nie 
zależy to od jego wielkości czy przeznaczenia. Oczywiście w projektach korporacyjnych,
dla klientów zewnętrznych, o wielkich budżetach i wymaganiach, taka analiza ma swoje
dobrze opisane zasady. Ludzie ją przeprowadzający komunikują się z odbiorcą 
projektu w celu ustalenia celów i wypracowania możliwych do realizacji założeń.
Mogą przy tym korzystać z bardzo rozbudowanych, drogich programów tworzonych
przez równie duże korporacje. Z programów, o których można posłuchać na wykładach 
z inżynierii oprogramowania, a których nikt nigdy nie widział w swoim zakładzie 
pracy i raczenie już nie zobaczy. Po wszystkim powstaje jakiś dokument, o także z 
góry zdefiniowanej strukturze, dobrze znanej wszystkim stronom lub przynajmniej 
na tyle czytelnej aby nie było problemów z jego zrozumieniem gdy będzie trzeba 
rozliczyć projekt.&lt;/p&gt;

&lt;p&gt;Jednak nawet na niższym stopniu tej piramidy projektów dochodzi się w końcu do 
jakiejś formy analizy wymagań. &lt;strong&gt;Nawet gdy piszesz program tylko dla siebie&lt;/strong&gt;, to w 
głowie zakładasz sobie jak on powinien wyglądać gdy już skończysz. Być może nie 
od razu wszystkie te założenia przyjdą Ci na myśl, a być może o niektórych z nich 
zapomnisz w międzyczasie. Mimo tego, a może właśnie dlatego, &lt;strong&gt;dobrze jest spisać 
sobie wszystkie wymagania&lt;/strong&gt;, aby móc później do nich sprawnie zajrzeć w razie potrzeby. 
Spisane wymagania pozwalają także szybko przedstawić osobie trzeciej o co chodzi 
w całym projekcie i do czego mogłaby go było wykorzystać. I &lt;strong&gt;nie potrzebujesz do 
tego żadnych wymyślnych programów i metodologii!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;moscow&quot;&gt;MoSCoW&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://pl.wikipedia.org/wiki/Metoda_MoSCoW&quot;&gt;MoSCoW jest metodą opisu wymagań&lt;/a&gt; z czytelnym dla wszystkich szablonem. Wystarczy 
na kartce papieru, a w obecnych czasach w dokumencie otwartym w ulubionym edytorze
tekstu, napisać w 4 liniach zwroty: MUST HAVE, SHOULD HAVE, COULD HAVE, WON&#039;T HAVE,
a następnie wypełnić miejsce pod nimi kolejnymi wymaganiami dopasowanymi do właściwej
sekcji.&lt;/p&gt;

&lt;h4 id=&quot;sekcja-must-have&quot;&gt;Sekcja MUST HAVE&lt;/h4&gt;

&lt;p&gt;W tej sekcji powinny znaleźć się &lt;strong&gt;najważniejsze dla naszego projektu wymagania&lt;/strong&gt;,
bez których było by nam wstyd próbować komukolwiek wmówić że aplikacja jest gotowa.
Wyraz MUST można także rozszyfrować jak akronim &lt;strong&gt;Minimum Usable SubseT&lt;/strong&gt;. Jeśli
jesteś perfekcjonistą, może Ci się wydawać że tu powinno znaleźć się praktycznie 
wszystko co podczas tworzenia aplikacji przyjdzie Ci do głowy, ale poczekaj, są
jeszcze inne sekcje do wypełnienia...&lt;/p&gt;

&lt;h4 id=&quot;sekcja-should-have&quot;&gt;Sekcja SHOULD HAVE&lt;/h4&gt;

&lt;p&gt;W sekcji &quot;powinno&quot; powinny znaleźć się &lt;strong&gt;wymagania które są wymagane aby móc uznać
projekt za skończony, ale na które masz jeszcze czas&lt;/strong&gt; i jesteś na obecnym etapie w
stanie w jakiś sposób obejść.&lt;/p&gt;

&lt;h4 id=&quot;sekcja-could-have&quot;&gt;Sekcja COULD HAVE&lt;/h4&gt;

&lt;p&gt;Ta sekcja może zostać wypełniona &lt;strong&gt;wymaganiami które byłyby dobrze widziane przez
klienta lub końcowych użytkowników, podniosłyby wartość całego projektu&lt;/strong&gt;, ale bez
których także będzie się czym pochwalić. To tymi wymaganiami powinieneś się zająć
w pierwszej kolejności gdy już się uporasz z sekcją MUST i SHOULD a masz jeszcze
trochę czasu.&lt;/p&gt;

&lt;h4 id=&quot;sekcja-won%27t-have&quot;&gt;Sekcja WON&#039;T HAVE&lt;/h4&gt;

&lt;p&gt;W ostatniej sekcji powinny znaleźć się &lt;strong&gt;najmniej istotne wymagania&lt;/strong&gt; które mogły pojawić
się podczas burzy mózgów na spotkaniach z klientem (lub samym sobą). Są to takie
wymagania które odpadają w przedbiegach bo nie będziesz w stanie w sensownym czasie
ich dostarczyć bądź zleceniodawca nie będzie w stanie za nie zapłacić. Dobrze
jest umieścić je w tej sekcji aby już więcej do nich nie wracać w przyszłości lub 
po to by móc drugiej stronie wskazać że miejsce tych wymagań zostało już wyznaczone.&lt;/p&gt;

&lt;h3 id=&quot;moscow-markdown&quot;&gt;MoSCoW Markdown&lt;/h3&gt;

&lt;p&gt;Markdown jest prostym językiem opisy struktury dokumentów tekstowych, zdobywającym
za przyczyną GitHuba coraz większą popularność. Jest bardzo przejrzysty nawet dla
osób widzących go pierwszy raz w życiu na oczy, może być łatwo konwertowany do
HTML, PDF i innych formatów. Jego składni można &lt;a href=&quot;https://blog.ghost.org/markdown/&quot;&gt;nauczyć się w kilka minut&lt;/a&gt;.
Wbudowana w GitHuba obsługa Markdown pozwala na łatwe przygotowanie treści i jej 
wyświetlenie w ładnej formie w przeglądarce internetowej osób przeglądających 
źródła projektu na GitHubie. &lt;strong&gt;Format ten może być wykorzystywany do tworzenia 
dokumentacji, dzienników zmian (changelogów) i innych około-projektowych dokumentów.&lt;/strong&gt; 
Dzięki swojej tekstowej formie może być także łatwo wersjonowany.&lt;/p&gt;

&lt;p&gt;Nie udało mi się niestety znaleźć w sieci gotowego szablonu dla raportów MoSCoW, 
postanowiłem więc być prekursorem i stworzyć takowy. A co! Może zyska on taką 
popularność jak &lt;a href=&quot;http://keepachangelog.com/&quot;&gt;format opisu changelogów&lt;/a&gt;!&lt;/p&gt;

&lt;h4 id=&quot;szablon-moscow-markdown&quot;&gt;Szablon MoSCoW Markdown&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# Requirements for project &#039;project name&#039;

## MUST have
- already done requirement [0.0.1]
- very important requirement

## SHOULD have
- important requirement

## COULD have
- interesting requirement

## WON&#039;T have
- unreachable requirement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Szablon taki składa się z nagłówka wskazującego nazwę projektu. Może zawierać
dodatkową informację o celu sporządzenia tego dokumentu - czyli dostarczeniu listy
wymagań. Następnie wypisane są ww. sekcje metody MoSCoW. Pod każdą z nich znajdują
się wpisy. Zrealizowane wymagania oznaczone są numerem wersji od której dane 
wymaganie uznano za spełnione.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-04-29T19:50:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/04/29/podroz-na-wschod-roadmap-z-moscow.html</link>
            <atom:link href="http://lion.net.pl/2016/04/29/podroz-na-wschod-roadmap-z-moscow.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/04/29/podroz-na-wschod-roadmap-z-moscow.html</guid>
        </item>
                <item>
            <title>I18N z angular-gettext</title>
            <dc:creator>Maciej Lew</dc:creator>
                                    <category>DSP2016</category>
                        <category>JS</category>
                        <category>DDF</category>
                                    <content:encoded>&lt;p&gt;I18N aplikacji może być niemałym problemem jeśli się o niej nie pomyśli zawczasu.
W tym wpisie dowiesz się jak można przeprowadzić łatwo i przyjemnie &lt;strong&gt;proces 
internacjonalizacji w AngularJS&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Internacjonalizacja to takie przygotowanie aplikacji, aby jej późniejsze 
przystosowanie dla odbiorców posługujących się innym językiem było jak najłatwiejsze
i jak najbardziej ustandaryzowane w ramach aplikacji. Dzięki I18N możemy otworzyć 
naszą aplikację na użytkowników którzy nie posługują się jej natywnym językiem.&lt;/p&gt;

&lt;h3 id=&quot;biblioteka-angular-gettext&quot;&gt;Biblioteka angular-gettext&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://angular-gettext.rocketeer.be/&quot;&gt;Biblioteka angular-gettext&lt;/a&gt; 
pozwala w łatwy sposób przystosować treść szablonów,
dyrektyw, a nawet komunikatów generowanych w kontrolerach frameworka AngularJS do
pracy w wielojęzycznym środowisku.&lt;/p&gt;

&lt;h4 id=&quot;instalacja-biblioteki&quot;&gt;Instalacja biblioteki&lt;/h4&gt;

&lt;p&gt;Instalacja biblioteki w projekcie polega na wydaniu kilku poleceń:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install --save angular-gettext
npm install grunt-angular-gettext --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Po ich wydaniu mamy bibliotekę dołączoną do zależności naszego projektu. Należy 
jeszcze ją odpowiednio skonfigurować.&lt;/p&gt;

&lt;h4 id=&quot;konfiguracja-biblioteki-i-narz%C4%99dzi-pomocniczych&quot;&gt;Konfiguracja biblioteki i narzędzi pomocniczych&lt;/h4&gt;

&lt;p&gt;Aby dodać przygotowane przez autora biblioteki pomocnicze narzędzia do grunta 
należy, w pliku &lt;em&gt;Gruntfile.js&lt;/em&gt;, wprowadzić następujące zmiany:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.loadNpmTasks(&#039;grunt-angular-gettext&#039;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Powyższe polecenie zaimportuje nam zestaw wbudowanych w angular-gettext narzędzi,
które także należy skonfigurować:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nggettext_extract: {
  pot: {
    options: {
      attributes: [&#039;placeholder&#039;]
    },
    files: {
      &#039;app/locale/en_UK/LC_MESSAGES/ddf.pot&#039;: [&#039;app/partials/*.html&#039;]
    }
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Narzędzie &lt;strong&gt;nggettext_compile służy do wyszukiwania w kodzie aplikacji tekstów
do przetłumaczenia&lt;/strong&gt;. W powyższej konfiguracji dodajemy dodatkowy atrybut HTML,
którego wartość ma być również brana pod uwagę podczas analizowania kodu (o tym 
jak oznaczać teksty do tłumaczenia a także o własnych dyrektywach przeczytasz
poniżej). Wskazujemy także lokalizację pliku POT, czyli szablonu dla wszystkich 
tłumaczeń oraz lokalizację, która ma zostać przeszukana pod kątem tekstów oznaczonych
jako do przetłumaczenia.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nggettext_compile: {
  all: {
    files: {
      &#039;app/scripts/translations.js&#039;: [&#039;app/locale/**/*.po&#039;]
    }
  },
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Narzędzie &lt;strong&gt;nggettext_extract służy do kompilacji przygotowanych plików PO z 
tłumaczeniami do kodu JS&lt;/strong&gt;. Wskazujemy tu ścieżkę w której ma zostać utworzony 
skompilowany plik oraz ścieżkę w której znajdują się pliki z gotowymi tłumaczeniami.&lt;/p&gt;

&lt;p&gt;Ponad to, należy w pliku index.html załadować bibliotekę oraz plik z tłumaczeniami,
najlepiej przed kodem samej aplikacji:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;bower_components/angular-gettext/dist/angular-gettext.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;scripts/translations.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kolejnym krokiem jest wstrzyknięcie modułu do naszej aplikacji, np:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dependencies = [&#039;gettext&#039;, &#039;ionic&#039;, &#039;ui.router&#039;, &#039;DrugDoseFrameworkControllers&#039;];
var app = angular.module(&#039;DrugDoseFrameworkApp&#039;, dependencies);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Możemy także uzależnić język aplikacji od ustawień przeglądarki klienta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.run(function ($ionicPlatform, gettextCatalog) {
    switch (window.navigator.language.substr(0, 2)) {
        case &#039;pl&#039;:
            gettextCatalog.setCurrentLanguage(&#039;pl_PL&#039;);
            break;
        case &#039;de&#039;:
            gettextCatalog.setCurrentLanguage(&#039;de_DE&#039;);
            break;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lub podpiąć metodę &lt;em&gt;setCurrentLanguage&lt;/em&gt; pod jakiś element interfejsu umożliwiając
tym samym zmianę języka samemu użytkownikowi, wedle jego upodobań.&lt;/p&gt;

&lt;h4 id=&quot;przygotowanie-tekst%C3%B3w&quot;&gt;Przygotowanie tekstów&lt;/h4&gt;

&lt;p&gt;Biblioteka angular-gettext definiuje kilka sposobów w jaki możemy przygotować
teksty do tłumaczeń tak, aby mogły zostać przez nie odnalezione. Pierwszym z nich 
jest &lt;strong&gt;otoczenie tekstu znacznikiem \&amp;lt;translate&amp;#62;&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;translate&amp;gt;sentence to translate&amp;lt;/translate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jeśli nasz tekst znajduje się już w innym znaczniku nie musimy wprowadzać kolejnego,
&lt;strong&gt;możemy użyć atrybutu translate&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span translate&amp;gt;sentence to translate&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Innym pomysłem może być &lt;strong&gt;użycie filtru translate&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ &quot;{{ &#039;sentence to translate&#039; | translate &quot; }}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Możemy także przygotować własną dyrektywę wspierającą tłumaczenia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.directive(&#039;placeholder&#039;, [&#039;gettextCatalog&#039;, function (gettextCatalog) {
    return {
        restrict: &#039;A&#039;,
        link: function (scope, element, attrs) {
            element.attr(&#039;placeholder&#039;, gettextCatalog.getString(attrs.placeholder));
        }
    };
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jeśli chcemy przetłumaczyć coś w kontrolerze to należy do tego wykorzystać metodę
getString, jak pokazałem w powyższym przykładzie.&lt;/p&gt;

&lt;p&gt;Biblioteka angular-gettext wspiera także takie zaawansowane opcje jak: komentarze 
do tłumaczeń, kontekst tłumaczeń (rzeczownik, czasownik, itp.), tłumaczenia w 
liczbie mnogiej, interpolację zmiennych w tłumaczone teksty, lazy-loading tłumaczeń.
O tym wszystkim możesz poczytać w 
&lt;a href=&quot;https://angular-gettext.rocketeer.be/dev-guide/&quot;&gt;bardzo dobrej dokumentacji biblioteki&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;t%C5%82umaczenie-tekst%C3%B3w&quot;&gt;Tłumaczenie tekstów&lt;/h4&gt;

&lt;p&gt;Gdy mamy już oznaczony tekst który chcemy przetłumaczyć, nadchodzi pora aby się 
za to zabrać. Na szczęście nie musimy go teraz szukać ponownie i przepisywać do
plików z tłumaczeniami. Należy wykonać komendę &lt;strong&gt;grunt nggettext_extract&lt;/strong&gt;. W
lokalizacji wskazanej w konfiguracji tego narzędzia znajdziemy plik POT, a w nim 
wszystkie znalezione teksty, wraz z ich lokalizacją w projekcie. W kolejnym kroku 
należy skopiować szablon, zmieniając mu rozszerzenie na PO, do lokalizacji tłumaczeń
które chcemy obsługiwać (nazwa pliku może być dowolna), np:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app

&lt;ul&gt;
&lt;li&gt;locale

&lt;ul&gt;
&lt;li&gt;en_UK&lt;/li&gt;
&lt;li&gt;LC_MESSAGES

&lt;ul&gt;
&lt;li&gt;ddf.pot&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;pl_PL&lt;/li&gt;
&lt;li&gt;LC_MESSAGES

&lt;ul&gt;
&lt;li&gt;ddf.po&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;de_DE&lt;/li&gt;
&lt;li&gt;LC_MESSAGES

&lt;ul&gt;
&lt;li&gt;ddf.po&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Do pliku &lt;em&gt;ddf.po&lt;/em&gt; z polskimi tłumaczeniami należy skopiować zawartość szablonu POT.
Oprócz samego tłumaczenia możemy także uzupełnić nagłówki tego pliku, zgodnie z
&lt;a href=&quot;https://www.gnu.org/software/gettext/manual/html_node/Header-Entry.html&quot;&gt;dokumentacją formatu PO&lt;/a&gt;.
Nie jest to wymagane, ale może pomóc przyszłym tłumaczom naszej aplikacji.&lt;/p&gt;

&lt;p&gt;Gdy mamy już wszystko przetłumaczone należy skompilować to do pliku JS. Pomoże nam
w tym polecenie &lt;strong&gt;grunt nggettext_compile&lt;/strong&gt;. Po jego wykonaniu w pliku &lt;em&gt;translations.js&lt;/em&gt;
powinno znaleźć się coś podobnego do :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&#039;gettext&#039;).run([&#039;gettextCatalog&#039;, function (gettextCatalog) {
/* jshint -W100 */
    gettextCatalog.setStrings(&#039;de_DE&#039;, {
        &quot;Type drug name&quot;:&quot;Schreiben Sie die Medikamentennamen&quot;,
        &quot;calculate&quot;:&quot;berechnen&quot;
    });
    gettextCatalog.setStrings(&#039;pl_PL&#039;, {
        &quot;Type drug name&quot;:&quot;Wpisz nazwę leku&quot;,
        &quot;calculate&quot;:&quot;oblicz&quot;
    });
/* jshint +W100 */
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(linie zostały celowo zwinięte dla lepszej czytelności, normalnie wszystko jest 
zminimalizowane).&lt;/p&gt;

&lt;p&gt;Od teraz tłumaczenia są dostępne dla aplikacji. Jeśli zmiana języka aplikacji 
oparta jest o &lt;strong&gt;window.navigator.language&lt;/strong&gt; to możemy wszystko łatwo przetestować
zmieniając ustawienia języka w opcjach przeglądarki.&lt;/p&gt;

&lt;p&gt;Opisana tu procedura została przeze mnie wdrożona w mojej konkursowej aplikacji 
DDF. Jak to zrobiłem możesz 
&lt;a href=&quot;https://github.com/maciejlew/drug-dose-framework/commit/030e2680373f6f51471b34e085b1c687303a49f6&quot;&gt;zobaczyć na GitHubie&lt;/a&gt;. 
W razie problemów napisz komentarz - postaram się pomóc.&lt;/p&gt;
</content:encoded>
            <pubDate>2016-04-26T22:10:00+02:00</pubDate>
            <link>http://lion.net.pl/2016/04/26/i18n-z-angularjs-gettext.html</link>
            <atom:link href="http://lion.net.pl/2016/04/26/i18n-z-angularjs-gettext.html" rel="self" type="application/rss+xml" />
            <guid isPermaLink="true">http://lion.net.pl/2016/04/26/i18n-z-angularjs-gettext.html</guid>
        </item>
            </channel>
</rss>